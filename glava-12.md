# Глава 12. Автоматические очереди распределения вызовов

## Глава 12. Очереди автоматического распределения вызовов

>Англичанин, даже если он один, формирует упорядоченную очередь из одного человека.
>
>-- Джордж Майкс

Автоматическое распределение вызовов (ACD), или организация очереди вызовов, позволяет УАТС ставить в очередь входящие вызовы от нескольких пользователей. Он объединяет несколько вызовов в шаблон удержания, присваивает каждому вызову рейтинг и определяет порядок, в котором этот вызов должен быть доставлен доступному оператору (как правило, сначала в порядке очереди). Когда агент становится доступным, вызывающий абонент с самым высоким рейтингом в очереди доставляется этому агенту, а все остальные повышаются в рейтинге.

Если вы когда-либо звонили в организацию и слышали, что «все наши представители заняты», вы испытали ACD. Преимущество ACD для вызывающих абонентов в том, что им не нужно продолжать набирать номер в попытке связаться с кем-то, а преимущества для организаций заключаются в том, что они могут лучше обслуживать своих клиентов и решать проблему, когда звонящих больше, чем агентов.<sup><a href="#sn1">1</a></sup>

**Примечание**

Существует два типа колл-центров: входящие и исходящие. ACD относится к технологии, которая обрабатывает центры обработки входящих вызовов, тогда как термин _Dialer_ (или _Predictive Dialer_) относится к технологии, которая обрабатывает центры обработки исходящих вызовов. В этой книге мы прежде всего сосредоточимся на входящих звонках.

Мы все были разочарованы плохо спроектированными и управляемыми очередями: длительное удержание, радио вместо мелодии, ошеломляющее время ожидания и бессмысленные сообщения, которые каждые 20 секунд сообщают вам, насколько важен ваш звонок, несмотря на то, что вы ждали 30 минут и прослушали это сообщение так много раз, что можете процитировать его по памяти. С точки зрения обслуживания клиентов, дизайн очереди может быть одним из наиболее важных аспектов вашей телефонной системы. Как и в случае с автосекретарем, прежде всего следует помнить, что _ваши абоненты не заинтересованы в том, чтобы стоять в очереди_. Они позвонили, потому что _хотят с Вами поговорить_. Все ваши дизайнерские решения должны помнить об этом важном факте: люди хотят общаться с другими людьми, а не с Вашей телефонной системой.<sup><a href="#sn2">2</a></sup>

Цель этой главы - научить вас, как создавать и проектировать очереди, которые доставляют абонентов по назначению максимально быстро и безболезненно.

**Примечание**

В этой главе мы можем переключаться между использованием терминов _queue members_ и _agents_. Так как мы не собираемся тратить много времени на модуль Asterisk с именем `chan_agent` (используя `AgentLogin()`), нам нужно прояснить, что в этой книге, когда мы используем термин _agent_, имеется в виду конечный пользователь - человек, а не канальная технология в Asterisk с именем `chan_agent`. Читайте дальше, и это обретёт больше смысла.

## Создание простой очереди ACD

Для начала мы собираемся создать простую очередь ACD. Она будет принимать звонящих и пытаться доставить их участнику очереди.

**Примечание**

В Asterisk термин _member_ относится к каналу (обычно одноранговому узлу SIP), назначенному очереди, которую можно набрать, например, `SIP/0000FFFF0001`. _agent_ технически относится к каналу агента, также используемому для набора конечных точек. К сожалению, канал агента является устаревшей технологией в Asterisk, так как он ограничен в гибкости и может вызвать непредвиденные проблемы, которые трудно диагностировать и разрешать. Мы не будем охватывать использование `change_agent`, поэтому имейте в виду, что мы будем использовать термин `member`(участник) для обозначения телефонного устройства и `agent` (агент) для обозначения лица, которое обрабатывает вызов. Поскольку один из них, как правило, не эффективен без другого, любой термин может относиться к обоим.

Мы создадим очередь(и) в файле _queues.conf_ и добавим в нее участников очереди через консоль Asterisk. В разделе “Участники Очереди” мы рассмотрим, как создать абонентскую группу, которая позволяет нам динамически добавлять и удалять участников очереди (а также приостанавливать и возобновлять их).

Первым шагом является создание пустого файла _agents.conf_ в вашем каталоге конфигурации _/etc/asterisk_. Мы не будем использовать или редактировать этот файл, но модуль `app_queue` ожидает его нахождения и не будет загружаться, если файл не существует:

```
$ cd /etc/asterisk
$ sudo -u asterisk touch agents.conf
```
Поскольку мы еще не сделали этого, мы также собираемся настроить базовую музыку в режиме ожидания (MOH), используя файл примера:
```
$ sudo cp ~/src/asterisk-16.*/configs/samples/musiconhold.conf.sample /etc/asterisk/musiconhold.conf

$ sudo chown asterisk:asterisk /etc/asterisk/musiconhold.conf
```
Затем вам нужно создать файл _queues.conf_, но мы не будем его редактировать, потому что мы будем создавать наши очереди в базе данных (файл просто должен быть там):
```
$ sudo touch -u asterisk queues.conf
```
Далее мы создадим несколько очередей в нашей базе данных:
```
MySQL>; INSERT INTO `asterisk`.`queues`

(name,strategy,joinempty,leavewhenempty,ringinuse,autofill,musiconhold, 
monitor_format,monitor_type)

VALUES
'sales','rrmemory','unavailable,invalid,unknown','unavailable,invalid,unknown','no','yes',
'default','wav','MixMonitor'),
('support','rrmemory','unavailable,invalid,unknown','unavailable,invalid,unknown','no',
'yes','default','wav','MixMonitor') ;
```
Это даст нам две очереди, названные `sales` и `support`. Вы можете называть их как угодно, но мы будем использовать эти имена позже в этой книге, поэтому, если вы используете имена очередей, отличные от тех, которые мы использовали здесь, запомните или запишите ваши названия для дальнейшего использования.

Мы также определили параметры очередей, изложенные в Таблице 12-1.

Таблица 12-1. _Примерные параметры очереди_

| Parameter | Purpose |
| :--- | :--- |
| `strategy=rrmemory` | Используйте стратегию кругового перебора с памятью |
| `joinempty=unavailable,invalid,unknown` | Не присоединятся к очереди, когда нет доступных участников |
| `leavewhenempty=unavailable,invalid,unknown` | Покинуть очередь, когда нет доступных участников |
| `ringinuse=no` | Не звонить участникам, когда они уже используются (предотвращает многократные звонки участникам)|
| `autofill=yes` | Распределить всех ожидающих абонентов среди доступных участников |
| `musiconhold=default` | Воспроизведение музыки из класса `[default]` (см. <code>musiconhold.conf</code>) |

`strategy`, которую мы будем использовать, - это `rrmemory`, что означает круговой перебор с памятью. Стратегия `rrmemory` работает путем чередования агентов в очереди в последовательном порядке, отслеживая, какой агент получил последний вызов, и предоставляя следующий вызов следующему агенту. Когда он попадает к последнему агенту, он возвращается к началу (при входе агентов они добавляются в конец списка).
##
**Несколько примечаний по  Стратегиям**

`ringall`

Звонит всем доступным участникам (по умолчанию). Эта стратегия распределения на самом деле не считается ACD. В традиционных терминах телефонии это называется "групповой вызов" (_ring group_).

`leastrecent`

Каждый следующий звонок будет получать участник, который в последний раз положил трубку раньше всех остальных. В очереди, где есть много вызовов примерно одинаковой продолжительности, это справедливо.  Но это не будет справеливым, если агент был на вызове в течение часа а все его коллеги получили последний звонок 30 минут назад,потому что агент, который закончил последним свой 60-минутный вызов получит следующий звонок.

`fewestcalls`

Вызывается первый свободный участник, который обработал наименьшее количество вызовов из данной очереди. Это может быть несправедливо, если звонки не всегда имеют одинаковую продолжительность. Агент мог обрабатывать три звонка по 15 минут каждый, а его коллега имел четыре 5-секундных звонка; агент, который обработал три звонка, получит следующий звонок.

`random`

Звонит случайный интерфейс. Это на самом деле может быть хорошо и в конечном итоге будет очень справедливым с точки зрения равномерного распределения вызовов между агентами.

`rrmemory`

Обзванивает участников по кругу, запоминается последний участник, ответивший на вызов. Это также может быть справедливым, но не так как `random`.

`linear`

Звонит участникам в указанном порядке, всегда начиная с начала списка. Это работает, если у вас есть команда, в которой есть некоторые агенты, которые должны обрабатывать большинство вызовов, и другие агенты, которые должны получать вызовы, только если  основные агенты заняты.

`wrandom`

Звонит случайному участнику, но использует пенальти `penalty` (ударение на первую букву "е") участников в качестве веса `weight`. Стоит рассмотреть в очередях с большой нагрузкой  cреди агентов.
##
Мы установили `joinempty` на `no`, так как ставить абонентов в очередь, где нет доступных агентов чтобы принимать их звонки это плохо.

**Примечание**

Вы можете установить это значение в `yes` для удобства тестирования, но мы не рекомендуем запускать его в производство, если вы не используете очередь для какой-либо функции, которая не предназначена для передачи абонентов вашим агентам. Никто не хочет ждать в очереди, которая никуда не идет.

Опция `leavewhenempty` используется для управления тем, должны ли абоненты выпадать из приложения `Queue()` и продолжать работу в диалплане, если ни один из участников не может принимать их вызовы. Мы установили это значение на `yes`, потому что обычно вы не хотите, чтобы абоненты ждали в очереди без зарегистрированных агентов.

**Примечание**

С точки зрения бизнеса, вы должны сказать своим агентам, чтобы они очистили все звонки из очереди, прежде чем выходить из системы в течение дня. Если вы обнаружите, что в конце дня в очереди много вызовов, возможно, вы захотите продлить чью-то смену, чтобы обслужить их. В противном случае, они просто добавят вам стресса, когда перезвонят на следующий день в худшем настроении.

Вы можете использовать `GotoIfTime()` ближе к концу дня, чтобы перенаправить абонентов на голосовую почту или другое подходящее место в вашем диалплане, пока ваши агенты очищают все оставшиеся вызовы в очереди.

Мы будем ставить `ringinuse` на `no`, что говорит Asterisk не звонить участникам, когда их устройства уже используются. Целью установки `ringinuse` в `no` является предотвращение многократных вызовов одного и того же участника из одной или нескольких очередей.

**Примечание**

Следует отметить, что упомянутые `joinempty` и `leftwhenempty` ищут либо участников, не вошедших в очередь, либо недоступных участников. Агенты, которые являются `Ringing` или `InUse`, не считаются недоступными, поэтому не будут блокировать абонентов от присоединения к очереди и заставлять их отключаться, когда `joinempty=no` и/или `leftwhenempty=yes`.

Опция `autofill` указывает очереди немедленно распределить всех ожидающих абонентов между всеми доступными участниками. Предыдущие версии Asterisk распределяли только одного абонента за один раз, что означало, что в то время как Asterisk подавал сигнал агенту, все остальные вызовы удерживались (даже если другие агенты были доступны) до тех пор, пока первый абонент в очереди не был подключен к агенту (что, очевидно, приводило к узким местам в старых версиях Asterisk, где использовались занятые очереди). Если у вас нет особой потребности в обратной совместимости, _этот параметр всегда_ должен быть установлен в `yes`.

Убедитесь, что ваш файл _/etc/asterisk/extconfig_ содержит следующие строки:
```
queues => odbc,asterisk,queues
queue_members => odbc,asterisk,queue_members
```
Сохраните и перезагрузите конфигурацию очереди из интерфейса командной строки Asterisk CLI:
```
*CLI> queues reload
```
Убедитесь, что ваши очереди были загружены в память (не забудьте убедиться, что файл _agents.conf_ существует:
```
localhost*CLI> queue show
support has 0 calls (max unlimited) in 'rrmemory' strategy
(0s holdtime, 0s talktime), W:0, C:0, A:0, SL:0.0% within 0s
 No Members
 No Callers

sales has 0 calls (max unlimited) in 'rrmemory' strategy
(0s holdtime, 0s talktime), W:0, C:0, A:0, SL:0.0% within 0s
 No Members
 No Callers
```
Выходные данные `queue show` предоставляют различную информацию, в том числе детали, подробно описанные в Таблице 12-2.

Таблица 12-2. _Описание вывода queue show_

| Field | Description |
| :--- | :--- |
| W: | Вес очереди |
| C: | Количество вызовов в очереди |
| A: | Количество звонков, на которые ответил участник |
| SL: | Уровень обслуживания |

Теперь, когда вы создали очереди, вам нужно настроить диалплан так, чтобы звонки могли входить в очередь.

Добавьте следующую логику плана набора в файл _extensions.conf_ (где-нибудь в контексте `[sets]`):
```
exten => 610,1,Noop()
 same => n,Progress()
 same => n,Queue(sales)
 same => n,Hangup()

exten => 611,1,Noop()
 same => n,Progress()
 same => n,Queue(support)
 same => n,Hangup()
```
Сохраните изменения в файле extensions.conf и перезагрузите план набора с помощью команды CLI перезагрузки `dialplan reload`.

Если вы наберете добавочный номер 610 или 611, вы получите следующий вывод:
```
== Setting global variable 'SIPDOMAIN' to '172.29.1.178'
-- Executing [610@sets:1] NoOp("PJSIP/SOFTPHONE_A-00000004", "") in new stack
-- Executing [610@sets:2] Progress("PJSIP/SOFTPHONE_A-00000004", "") in new stack
-- Executing [610@sets:3] Queue("PJSIP/SOFTPHONE_A-00000004", "test") in new stack
   > 0x7facc801ed60 -- Strict RTP learning after remote set to: 172.29.1.166:4022
-- Started music on hold, class 'testmoh', on channel 'PJSIP/SOFTPHONE_A-00000004'
   > 0x7facc801ed60 -- Strict RTP switching to RTP target 172.29.1.166:4022 as source
   > 0x7facc801ed60 -- Strict RTP learning complete - Locking on 172.29.1.166:4022
-- Stopped music on hold on PJSIP/SOFTPHONE_A-00000004
== Spawn extension (sets, 610, 3) exited non-zero on 'PJSIP/SOFTPHONE_A-00000004'
```
Обратите внимание, что в этот момент вы не присоединитесь к очереди, потому что в очереди нет агентов для ответа на вызовы. У нас настроены `joinempty=no` и `leftwhenempty=yes`, поэтому вызывающие не будут помещаться в очередь. (Это была бы хорошая возможность поэкспериментировать с опциями `joinempty` и `leftwhenempty` в _queues.conf_, чтобы лучше понять их влияние на очереди)

В следующем разделе мы покажем, как добавлять участников в очередь (а также другие взаимодействия участников с очередью, такие как пауза/отмена паузы).

## Участники очереди

Очереди не очень полезны, если кто-то не отвечает на входящие вызовы, поэтому нам нужен метод, позволяющий агентам входить в очереди для ответа на вызовы. Существуют различные способы решения этой задачи, поэтому мы покажем вам, как добавлять участников в очередь как вручную (как администратор, через CLI или жестко прописанную в таблице `queue_members`), так и динамически (в качестве агента через расширение, определенное в диалплане). Мы начнем с метода Asterisk CLI, который позволяет легко добавлять участников в очередь для тестирования с минимальными изменениями плана набора. Далее мы покажем, как вы можете определить участников в таблице `queue_members`. Наконец, мы покажем вам, как добавить логику диалплана, которая позволяет агентам входить в очереди и выходить из них, а также приостанавливать и возобновлять себя в очередях, в которые они вошли (это, вероятно, лучший метод для производства).

### Управление участниками очереди через CLI

Мы можем добавить членов очереди в любую доступную очередь через команду очереди Asterisk CLI `queue add`. Формат команды добавления очереди `queue add` (все в одной строке):
<pre>
 <code style="font-size:12px">
  *CLI> queue add member <i>channel</i> to queue [[[penalty <i>penalty</i>] as <i>membername</i>]state_interface <i>interface</i>]
 </code>
</pre>
`channel` - это канал, который мы хотим добавить в очередь, например SIP/0000FFFF0003, а имя `queue` будет что-то вроде `support` или `sales` - любое имя очереди, которое существует в _/etc/asterisk/queues.conf_. Пока мы будем игнорировать вариант c `penalty`, но мы обсудим его в разделе «Расширенные очереди» (`penalty` используется для контроля ранга участника в очереди, что может быть важно для операторов, которые вошли в несколько очередей или имеют разные навыки). Мы можем определить `membername`, чтобы предоставить подробные сведения для механизма регистрации очередей.

Опция `state_interface` информирует очередь о состоянии устройства, которое будет отслеживаться для этого агента. Детали работы с состояниями устройства обсуждаются в [Главе 13](glava-13.md). Сходите и проработайте эту главу, а затем вернитесь сюда и продолжайте. Не волнуйся, мы подождем.

Теперь, когда вы добавили `callcounter=yes` в _sip.conf_ (мы будем использовать SIP-каналы во всех остальных наших примерах), давайте посмотрим, как добавлять участников в наши очереди из Asterisk CLI.

Добавление участника очереди в очередь `support` можно выполнить с помощью команды `queue add member`:
```
*CLI> queue add member PJSIP/SOFTPHONE_B to support

Added interface 'PJSIP/SOFTPHON_B' to queue 'support'
```
Запрос очереди подтвердит, что наш новый участник был добавлен:
```
*CLI> queue show support

support has 0 calls (max unlimited) in 'rrmemory' strategy (0s holdtime, 0s talktime),
W:0, C:0, A:0, SL:0.0%, SL2:0.0% within 0s
    Members:
        PJSIP/SOFTPHONE_B (ringinuse disabled) (dynamic)(Not in use) has taken no calls yet
    No Callers
```
Чтобы удалить участника очереди, вы должны использовать команду `queue remove member`:
```
*CLI> queue remove member PJSIP/SOFTPHONE_B from support

Removed interface PJSIP/SOFTPHONE_B from queue 'support'
```
Конечно, вы можете снова использовать команду `queue show`, чтобы убедиться, что ваш участник был удален из очереди:
```
*CLI> queue show support

support has 0 calls (max unlimited) in 'rrmemory' strategy (0s holdtime, 0s talktime),
W:0, C:0, A:0, SL:0.0%, SL2:0.0% within 0s
   Members:
      PJSIP/SOFTPHONE_B (ringinuse disabled) (dynamic) (Not in use) has taken no calls yet
   No Callers
```
Мы также можем приостанавливать и возобновлять участников в очереди из консоли Asterisk, используя команды `queuepause member` и `queue unpause member`. Они используют формат, аналогичный предыдущим командам, которые мы использовали:
```
*CLI> queue pause member PJSIP/SOFTPHONE_B queue support reason Callbacks

paused interface 'PJSIP/SOFTPHONE_B' in queue 'support' for reason 'Callbacks'

*CLI> queue show support
support has 0 calls (max unlimited) in 'rrmemory' strategy
(0s holdtime, 0s talktime), W:0, C:0, A:0, SL:0.0% within 0s
   Members:
      SIP/0000FFFF0001 (dynamic) (paused) (Not in use) has taken no calls yet
   No Callers

*CLI> queue show support

support has 0 calls (max unlimited) in 'rrmemory' strategy (0s holdtime, 0s talktime),
 W:0, C:0, A:0, SL:0.0%, SL2:0.0% within 0s
   Members:
      PJSIP/SOFTPHONE_B (ringinuse disabled) (dynamic) (paused:Callbacks) (Not in use)
has taken no calls yet
   No Callers
```
Добавляя причину (reason) приостановки работы участника очереди, например, время обеда (lunchtime), вы гарантируете, что ваши журналы очереди будут содержать дополнительную информацию, которая может оказаться полезной. Вот как можно приостановить участника:
```
*CLI> queue unpause member PJSIP/SOFTPHONE_B queue support reason FinishedCallBacks

unpaused interface 'PJSIP/SOFTPHONE_B' in queue 'support' for reason 'FinishedCallbacks'
```
В производственной среде CLI (интерфейс командной строки) обычно не является лучшим способом управления состоянием агентов в очереди. Вместо этого существуют приложения диалплана, которые позволяют агентам информировать очередь об их доступности.

### Определение участников очереди в таблице queue_members

Если вы определите участника очереди в таблице базы данных `asterisk.queue_members`, этот участник всегда будет зарегистрирован в очереди. Это обычно не очень хорошо, если ваши участники люди, так как люди, как правило, встают и передвигаются.

В каждом определении очереди вы просто определяете участников следующим образом:
```
MySQL> insert into `asterisk`.`queue_members`
(queue_name,interface,penalty)

VALUES
'hotline','PJSIP/SOME_NON_HUMAN','0');
```
В типичной очереди (в которой есть группа людей, отвечающих за ответы на вызовы), вы обнаружите, что определение участников в таблицу `queue_members` может навредить. Агенты должны иметь возможность входить и выходить из системы (а не автоматически регистрироваться всякий раз, когда очередь перезагружается). Мы не рекомендуем определять участников в таблице `queue_members`, если только нет других целей (таких как банк устройств, отвечающих на вызовы, где вы хотите использовать очередь для балансировки нагрузки вызовов в пул устройств или групповой вызов , где все телефоны звонят одновременно, независимо от того, сидит ли кто-нибудь рядом с телефоном).

### Управление участниками очереди с помощью логики диалплана

В колл-центре, в котором работают живые агенты, чаще всего сами агенты входят в систему и выходят из нее в начале и в конце своей смены (или когда они идут на обед, или в ванную, или иным образом недоступны для очереди).

Для этого мы будем использовать следующие приложения диалплана:

* `AddQueueMember()`
* `RemoveQueueMember()`

При входе в очередь может случиться так, что агенту необходимо перевести себя в состояние, когда он временно недоступен для приема вызовов. Следующие приложения позволят сделать это:

* `PauseQueueMember()`
* `UnpauseQueueMember()`

Приложения`Add`/`Remove` используются для входа и выхода из системы, а `Pause`/`Unpause` используются для коротких периодов отсутствия агента. Разница лишь в том, что `Pause` и `Unpause` устанавливают элемент как недоступный / доступный (`unavailable`/`available`), фактически не удаляя их из очереди. Это в основном полезно для отчетности (если участник приостановлен, администратор очереди может видеть, что он вошел в очередь, но просто недоступен для приема вызовов в этот момент). Если вы не уверены, какой из них использовать, мы рекомендуем агентам использовать `Add`/`Remove`, когда они физически не находятся у своего телефона, и `Pause`/`Unpause`, когда они находятся на своем рабочем месте, но временно недоступны.

Если есть сомнения, обычно лучше, чтобы ваши агенты вышли из системы (log out).

**Использование Пауза и Снять с паузы**

В некоторых средах `Pause` и `Unpause` используются для всех действий в течение дня, которые делают агента недоступным (например, во время обеденного перерыва и при выполнении работы, не связанной с очередью). Однако в большинстве центров обработки вызовов, если агент не находится рядом с телефоном и не готов принять вызов в этот момент, он вообще не должен входить в систему, даже если он будет отсутствовать на рабочем месте в течение нескольких минут. (например, для перерыва в ванной).

Некоторым руководителям нравится использовать настройки `Pause`/` Unpause` как своего рода часы, чтобы они могли отслеживать, когда их сотрудники приходят на работу и уезжают в конце дня, а также сколько времени они проводят за своими столами и на перерывах. Это может быть неразумной практикой, так как цель этих приложений-информировать очередь о доступности агента, а отслеживая активность- вторичной функцией.

Здесь важно отметить, что параметр `joinempty` в таблице `asterisk.queues` был рассмотрен ранее. Если агент приостановлен, он все еще находится в очереди. Предположим, что рабочая смена подходит к концу, а один агент несколько часов назад поставил себя на паузу для работы над проектом. Все остальные агенты вышли из системы и ушли домой. Поступает вызов. Очередь заметит, что агент вошел в очередь, и, следовательно, поставит вызов в очередь, несмотря на то, что в действительности в это время в этой очереди нет людей, способных ответить на вызов. Этот абонент может в конечном итоге задержаться в очереди без персонала на неопределенный срок.

Короче говоря, агенты, которые не сидят за столами и не планируют принимать звонки в течение следующих нескольких минут, должны выйти из системы. `Pause`/`Unpause` следует использовать только для кратковременных моментов недоступности (если вообще есть). Если вы хотите использовать свою телефонную систему в качестве звонильно-долбёжного агрегата, есть много отличных способов сделать это с помощью Asterisk, но приложения `queue member` это не тот способ, который мы посоветуем.

Давайте создадим простую логику набора номеров, которая позволит нашим агентам указывать свою доступность для очереди. Мы собираемся использовать функцию диалплана `CUT()`, чтобы извлечь имя нашего канала из нашего вызова в систему, чтобы очередь знала, какой канал входит в очередь.

Мы создали этот диалплан, чтобы показать простой процесс входа и выхода из очереди, а также изменения приостановленного статуса участника в очереди. Мы делаем это только для одной очереди, которую мы ранее определили в файле _queues.conf_. Переменные канала состояния, установленные приложениями `AddQueueMember()`, `Removeueemember()`, `Pauseueememember()` и `Unpauseuememember()`, могут использоваться для воспроизведения `Playback()` объявлений членам очереди после выполнения ими определенных функций, чтобы сообщить им, успешно ли они совершили вход/выход или пауза/продолжение:
```
exten => *731,1,Page(${PAGELIST},i,120)
exten => *732,1,Verbose(2,Logging In Queue Member)
 same => n,Set(MemberChannel=${CHANNEL(channeltype)}/${CHANNEL(endpoint)})
 same => n,AddQueueMember(support,${MemberChannel})
 same => n,Verbose(1,${AQMSTATUS}) ; ADDED, MEMBERALREADY, NOSUCHQUEUE
 same => n,Playback(agent-loginok)
 same => n,Hangup()

exten => *733,1,Verbose(2,Logging Out Queue Member)
 same => n,Set(MemberChannel=${CHANNEL(channeltype)}/${CHANNEL(endpoint)})
 same => n,RemoveQueueMember(support,${MemberChannel})
 same => n,Verbose(1,${RQMSTATUS}) ; REMOVED, NOTINQUEUE, NOSUCHQUEUE
 same => n,Playback(agent-loggedoff)
 same => n,Hangup()

exten => *734,1,Verbose(2,Pause Queue Member)
 same => n,Set(MemberChannel=${CHANNEL(channeltype)}/${CHANNEL(endpoint)})
 same => n,PauseQueueMember(support,${MemberChannel})
 same => n,Verbose(1,${PQMSTATUS}) ; PAUSED, NOTFOUND
 same => n,Playback(dictate/paused)
 same => n,Hangup()

exten => *735,1,Verbose(2,Unpause Queue Member)

 same => n,Set(MemberChannel=${CHANNEL(channeltype)}/${CHANNEL(endpoint)})
 same => n,UnpauseQueueMember(support,${MemberChannel})
 same => n,Verbose(1,${UPQMSTATUS}) ; UNPAUSED, NOTFOUND
 same => n,Playback(agent-loginok)
 same => n,Hangup()

exten => *98,1,NoOp(Access voicemail retrieval.)
```
### Автоматический вход и выход из нескольких очередей

Довольно часто агент является участником более чем одной очереди. Вместо того, чтобы иметь отдельное расширение для входа в каждую очередь (или требовать от агентов информацию о том, в какие очереди они хотят войти), этот код использует базу данных Asterisk (astdb) для хранения информации о участии в очереди для каждого агента, а затем циклически проходит через каждую очередь, в которую входят агенты, поочередно регистрируя их в каждой очереди.

Для того, чтобы этот код работал, необходимо добавить запись, аналогичную следующей, в AstDB через CLI Asterisk. Например, будет сохранён элемент SOFTPHONE_A как находящийся в очередях `support` и `sales`<sup><a href="#sn3">3</a></sup>
```
CLI> database put queue_agent SOFTPHONE_A/available_queues support^sales
```
Вам нужно будет сделать это один раз для каждого агента, независимо от того, скольких очередей они являются участниками.

Если вы запросите базу данных Asterisk, вы должны получить результат, подобный следующему:
```
pbx*CLI> database show queue_agent
/queue_agent/SOFTPHONE_A/available_queues : support^sales
```
Следующий код диалплана является примером того, как разрешить автоматическое добавление этого участника в очереди `support` и `sales`. Мы определили подпрограмму, которая используется для настройки трех канальных переменных (`Member Channel`,` Member Chan Type`,`AvailableQueues`). Эти переменные канала затем используют расширени Вход (`*736`), Выход (`*737`), Пауза (`*738`) Продолжение (`*739`). Каждое из расширений использует подпрограмму `subSetupAvailableQueues` чтобы установить эти переменные канала и убедиться, что AstDB содержит список одной или нескольких очередей для устройства, с которого вызывается участник очереди.

В конце вашего файла _extensions.conf_, куда вы поместили свои подпрограммы, добавьте следующее:
```
[subSetupAvailableQueues]
; Эта функция используется для различных процедур вход/выход/ пауза/продолжение
; в нашем примере входа в несколько очередей.
;
exten => start,1,Verbose(2,Checking for available queues)
; Get the current channel's peer name
same => n,Set(MemberChannel=${CHANNEL(endpoint)})
; Get the current channel's technology type
same => n,Set(MemberChanType=${CHANNEL(channeltype)})
; Get the list of queues available for this agent
same => n,Set(AvailableQueues=${DB(queue_agent/${MemberChannel}/available_queues)})
; if there are no queues assigned to this agent we'll handle it in the
; no_queues_available extension
same => n,GotoIf($[${ISNULL(${AvailableQueues})}]?no_queues_available,1)
same => n,Return()

exten => no_queues_available,1,Verbose(2,No queues available for agent ${MemberChannel})
; playback a message stating the channel has not yet been assigned
same => n,Playback(silence/1&channel&not-yet-assigned)
same => n,Hangup()
```
Далее, в контекст `[sets]`, добавьте следующие:
```
; Вход в несколько очередей через систему AstDB
exten => *736,1,Verbose(2,Logging into multiple queues per the database values)
; получить доступные очереди для этого канала
same => n,GoSub(subSetupAvailableQueues,start,1())
same => n,Set(QueueCounter=1) ; setup a counter variable
; используя CUT (), получите первую очередь из списка, возвращенную из AstDB.
; Обратите внимание, что мы использовали '^' в качестве разделителя.
same => n,Set(WorkingQueue=${CUT(AvailableQueues,^,${QueueCounter})})
; В то время как переменная канала WorkingQueue содержит значение, цикл
same => n,While($[${EXISTS(${WorkingQueue})}])
; AddQueueMember(queuename[,interface[,penalty[,options[,membername
;  [,stateinterface]]]]])
; Добавить канал в очередь, настроить интерфейс для вызова
;  и интерфейс для мониторинга состояния устройства
; *** Это все должно быть в одной строке
same => n,AddQueueMember(
    ${WorkingQueue},${MemberChanType}/${MemberChannel},,,${MemberChanType}/${MemberChannel})
    same => n,Set(QueueCounter=$[${QueueCounter} + 1])    ; увеличивает наш счетчик
; получить следующую доступную очередь; если она равна нулю, завершить цикл
    same => n,Set(WorkingQueue=${CUT(AvailableQueues,^,${QueueCounter})})
    same => n,EndWhile()
; пусть агент знает, что он вошёл в систему
   same => n,Playback(silence/1&agent-loginok)
   same => n,Hangup()

exten => no_queues_available,1,Verbose(2,No queues available for ${MemberChannel})
   same => n,Playback(silence/1&channel&not-yet-assigned)
   same => n,Hangup()

; Используется для регистрации агентов из всех настроенных очередей в базе данных AstDB
exten => *737,1,Verbose(2,Logging out of multiple queues)
; Поскольку мы повторно использовали некоторый код, мы поместили дубликат кода в подпрограмму
   same => n,GoSub(subSetupAvailableQueues,start,1())
   same => n,Set(QueueCounter=1)
   same => n,Set(WorkingQueue=${CUT(AvailableQueues,^,${QueueCounter})})
   same => n,While($[${EXISTS(${WorkingQueue})}])
   same => n,RemoveQueueMember(${WorkingQueue},${MemberChanType}/${MemberChannel})
   same => n,Set(QueueCounter=$[${QueueCounter} + 1])
   same => n,Set(WorkingQueue=${CUT(AvailableQueues,^,${QueueCounter})})
   same => n,EndWhile()
   same => n,Playback(silence/1&agent-loggedoff)
   same => n,Hangup()

; Используется для приостановки агентов во всех доступных очередях
exten => *738,1,Verbose(2,Pausing member in all queues)
   same => n,GoSub(subSetupAvailableQueues,start,1())
   ; если мы не определяем очередь, то участник приостанавливается во всех очередях
   same => n,PauseQueueMember(,${MemberChanType}/${MemberChannel})
   same => n,GotoIf($[${PQMSTATUS} = PAUSED]?agent_paused,1:agent_not_found,1)

exten => agent_paused,1,Verbose(2,Agent paused successfully)
   same => n,Playback(dictate/paused)
   same => n,Hangup()

; Используется для отмены паузы агентов во всех доступных очередях
exten => *739,1,Verbose(2,UnPausing member in all queues)
   same => n,GoSub(subSetupAvailableQueues,start,1())
 ; если мы не определяем очередь, то элемент не будет приостановлен из всех очередей
   same => n,UnPauseQueueMember(,${MemberChanType}/${MemberChannel})
   same => n,GotoIf($[${UPQMSTATUS} = UNPAUSED]?agent_unpaused,1:agent_not_found,1)

exten => agent_unpaused,1,Verbose(2,Agent paused successfully)
   same => n,Playback(silence/1&available)

; Используется как для приостановки, так и для продолжения функциональности диалплана
exten => agent_not_found,1,Verbose(2,Agent was not found)
   same => n,Playback(silence/1&cannot-complete-as-dialed)
```
Вы можете дополнительно усовершенствовать эти процедуры входа и выхода, чтобы учесть, что переменные канала `AQMSTATUS` и `RQMSTATUS` устанавливаются каждый раз, когда используются `AddQueueMember()` и `Removeueemember()`. Например, можно установить флаг, который позволяет участнику очереди знать, что он не был добавлен в очередь, или даже добавить записи или системы преобразования текста в речь для воспроизведения конкретной очереди, которая создает проблему. Или, если вы отслеживаете это через интерфейс Asterisk Manager, вы можете получить всплывающее окно экрана, или использовать `JabberSend()`, чтобы отправить участнику очереди мгновенное сообщение, или...(Разве Asterisk это не весело?).

## Расширенные очереди

В этом разделе мы рассмотрим некоторые более тонкие элементы управления очередью, такие как параметры управления объявлениями и когда абоненты (callers) должны быть помещены в очередь (или удалены из нее). Мы также рассмотрим пенальти ударение на первую букву "е") и приоритеты, исследуя, как мы можем контролировать агентов в нашей очереди, отдавая предпочтение пулу агентов, а затем увеличивая этот пул динамически на основе времени ожидания в очереди. Наконец, мы рассмотрим использование локальных каналов в качестве участников очереди, что дает нам возможность выполнять трюки диалплана до подключения абонента к агенту.

### Очередь с приоритетом (Queue Weighting)

Иногда вам нужно добавить людей в очередь с более высоким приоритетом, чем у других абонентов. Возможно, абонент уже провел некоторое время в очереди, и агент принял некоторую информацию, но понял, что абонент должен быть переведен в другую очередь. В этом случае, чтобы свести к минимуму общее время ожидания абонента, возможно, было бы желательно перенести вызов в приоритетную очередь, которая имеет более высокий вес (`weight`) (и, следовательно, более высокое предпочтение), где ему быстрее ответят.

Установка более высокого приоритета для очереди выполняется с помощью параметра `weight`. Если у вас есть две очереди с разными весом (например, `support` и `support-priority`), агентам, назначенным в обе очереди, будут переданы вызовы из очереди с более высоким приоритетом, а не вызовы из очереди с более низким приоритетом. Эти агенты не будут принимать никаких вызовов из очереди с более низким приоритетом, пока очередь с более высоким приоритетом не будет очищена. (Обычно есть некоторые агенты, которые назначаются только в очередь с более низким приоритетом, чтобы гарантировать своевременную обработку этих вызовов.) Например, если мы поместим участника очереди Джеймса Шоу в обе очереди `support` и `support-priority`, абоненты в очереди `support-priority` будут иметь предпочтительное положение вместе с Джеймсом, по сравнению с абонентами в очереди `support`.

Давайте посмотрим, как бы мы реализовали это. Во-первых, нам нужно создать новую очередь, аналогичную очереди `support`, за исключением опции `weight`.
```
MySQL> INSERT INTO `asterisk`.`queues`
(name,strategy,joinempty,leavewhenempty,ringinuse,autofill,musiconhold,monitor_format,
monitor_type,weight)

VALUES
('support-priority','rrmemory','unavailable,invalid,unknown','unavailable,invalid,unknown',
'no','yes','default','wav','MixMonitor','10');
```
С нашей новой настроенной очередью мы можем теперь создать два расширения для перевода абонентов. Это можно сделать везде, где вы обычно размещаете логику диалплана для выполнения переводов. Мы будем использовать контекст `LocalSets`, который мы ранее включили в качестве начального контекста для наших устройств:
```
exten => 611,1,Noop()
   same => n,Progress()
   same => n,Queue(support)
   same => n,Hangup()
exten => 612,1,Noop()
   same => n,Progress()
   same => n,Queue(support-priority)
   same => n,Hangup()
exten => *724,1,Noop(Page)
```
Осталось убедиться, что все ваши участники очереди помещены в обе очереди.

### Приоритет Участника Очереди 

Внутри очереди мы можем применить пенальти к участникам, чтобы уменьшить их предпочтение быть вызванными, когда есть люди, ожидающие в определенной очереди. Например, мы можем применять пенальти, когда хотим, чтобы они были участниками очереди, но принимали вызовы только тогда, когда очередь заполнится до тех пор, когда все наши предпочтительные агенты будут недоступны. Выставляя величину пенальти для каждого участника очереди,<sup><a href="#sn4">4</a></sup> мы можем контролировать предпочтения, куда приходят звонки, но при этом гарантировать, что другие участники очереди будут доступны для ответа абонентов, если предпочтительный участник недоступен.

Пенальти также могут быть определены с помощью `AddQueueMember ()`. Мы изменим наш вход в несколько очередей, чтобы обеспечить необходимые пенальти.

Во-первых, давайте обновим нашу AstDB, чтобы включить пенальти для участника:
```
*CLI> database put queue_agent SOFTPHONE_A/penalty 0^2

*CLI> database show queue agent

/queue_agent/SOFTPHONE_A/available_queues : support^sales
/queue_agent/SOFTPHONE_A/penalty : 0^2
```
Далее, несколько изменений в нашем диалплане.
Подпрограмме нужна новая строка (некоторый код был удален для краткости, заменен на; ...):
<pre>
 <code style="font-size:12px">
[subSetupAvailableQueues]
; ...
; Получить список очередей, доступных для этого агента
   same => n,Set(AvailableQueues=${DB(queue_agent/${MemberChannel}/available_queues)})
   <b>same => n,Set(MemberPenalties=${DB(queue_agent/${MemberChannel}/penalty)})</b>
; если нет назначенных очередей ...
 </code>
</pre>
Контекст `[sets]` также требует нескольких новых строк (некоторый код был удален для краткости, заменен на; ...). Только вставляйте / меняйте код, выделенный жирным шрифтом.
<pre>
 <code style="font-size:12px">
exten => *736,1,Verbose(2,Logging into multiple queues per the database values)
; ...
   same => n,Set(WorkingQueue=${CUT(AvailableQueues,^,${QueueCounter})})
   <b>same => n,Set(WorkingPenalty=${CUT(MemberPenalties,^,${QueueCounter})})</b>
; While the WorkingQueue ...
; ...
     same => n,Set(WorkingQueue=${CUT(AvailableQueues,^,${QueueCounter})})
     <b>same => n,Set(WorkingPenalty=${CUT(MemberPenalties,^,${QueueCounter})})</b>
     same => n,EndWhile()
; ...
 </code>
</pre>
Эти примеры, вероятно, не подходят для производственной среды (мы бы использовали специально построенные таблицы MySQL для такого рода вещей, а не AstDB), но это дает вам представление о том, как диалплан может быть использован для применения динамической логики к более сложным сценариям конфигурации.

### Динамическое изменение пенальти (queuerules)

Используя таблицу `asterisk.queuerules`, можно определить правила, которые изменяют значения переменных канала `QUEUE_MIN_PENALTY` и `QUEUE_MAX_PENALTY`. Переменные канала `QUEUE_MIN_PENALTY` и `QUEUE_MAX_PENALTY` используются для управления тем, какие участники очереди предпочтительнее для обслуживания абонентов. Допустим, у нас есть очередь с именем `support`, и у нас есть пять участников очереди с различными пенальти в диапазоне от 1 до 5. Если до того, как абонент войдет в очередь, для переменной канала `QUEUE_MIN_PENALTY` задано значение 2, а для `QUEUE_MAX_PENALTY` - значение 4, то для ответа на этот вызов будут считаться доступными только участники очереди, пенальти которых находятся в диапазоне от 2 до 4.:
```
same => n,Set(QUEUE_MIN_PENALTY=2) ; установить минимальный пенальти участника
same => n,Set(QUEUE_MAX_PENALTY=4) ; установить максимальное пенальти участника
same => n,Queue(support) ; вход в очередь с минимальными и максимальными пенальти
                         ; для участников, которые будут использоваться
```
Более того, во время пребывания абонента в очереди мы можем динамически изменять значения `QUEUE_MIN_PENALTY` и `QUEUE_MAX_PENALTY` для этого абонента. Это позволяет использовать либо больше, либо другой набор участников очереди, в зависимости от того, как долго вызывающий абонент ожидает в очереди. Например, в предыдущем примере мы могли бы изменить минимальное пенальти на 1 и максимальное пенальти на 5, если абонент находится более 60 секунд в очереди.

Файл примера _~/src/asterisk-15.*/configs/samples/queuerules.conf.sample_ содержит отличную справку о том, как работают правила очереди.

Правила определяются с использованием таблицы `asterisk.queuerules`. Несколько правил могут быть созданы для того, чтобы облегчить различные изменения пенальти на протяжении всего вызова. Давайте посмотрим, как мы можем определить правило.:
```
MySQL> insert into `asterisk`.`queue_rules`
(rule_name,time,min_penalty,max_penalty)

VALUES
('more_members',60,5,1);
```
**Примечание**

Новые правила будут касаться только новых абонентов, входящих в очередь, а не существующих абонентов, которые уже находятся в ней.
Мы назвали правило `more_members` и определили следующие значения:

60  Количество секунд ожидания перед изменением значений пеналти.<br>
5   Новый `QUEUE_MAX_PENALTY`.<br>
1   Новый `QUEUE_MIN_PENALTY`.

Теперь мы можем сказать нашим очередям использовать его.
```
MySQL> update `asterisk`.`queues`

set defaultrule='more_members' where `name` in ('sales','support')
```
Файл _queuerules.conf.sample_ показывает, что эти правила достаточно гибкие. Если вы хотите детально контролировать приоритеты вызовов, вам может потребоваться дополнительная лабораторная работа.

### Управление Объявлениями

Asterisk имеет возможность проигрывать несколько объявлений абонентам, ожидающим в очереди. Например, вы можете объявить позицию вызывающего абонента в очереди, объявить среднее время ожидания или периодически благодарить вызывающих абонентов за ожидание (или все, что скажут ваши аудиофайлы). Важно тщательно настроить значения, которые контролируют, когда эти объявления воспроизводятся для абонентов, потому что объявление их позиции, благодарность им за ожидание и информирование их о среднем времени ожидания слишком часто будет раздражать их, что не является нашей целью.

**Воспроизведение объявлений между музыкальными файлами на удержании**

Вместо того, чтобы разбираться со сложностями объявлений для каждой из ваших очередей, вы можете альтернативно (или совместно) использовать функциональность объявления, определенную в _musiconhold.conf_. Перед воспроизведением файла музыки на удержании будет воспроизведен файл объявления, а затем воспроизведен снова между аудиофайлами. Допустим, у вас есть 5-минутный цикл аудио, но вы хотите воспроизводить сообщение “Спасибо за ожидание” каждые 30 секунд. Вы можете разбить аудиофайл на 30-секундные сегменты, задать их имена, начиная с `00-`, `01-`, `02-` и так далее (чтобы они воспроизводились по порядку), а затем определить объявление The _musiconhold.conf_ может выглядеть примерно так:
```
[moh_jazz_queue]
mode=files
sort=alpha
announcement=queue-thankyou
directory=moh_jazz_queue
```
В таблице очередей есть несколько параметров, которые можно использовать для точной настройки того, какие и когда объявления воспроизводятся для ваших абонентов. Полный список опций очереди доступен в разделе _~/src/asterisk-16.*/configs/samples/queues.conf.sample_. Таблица 12-3 рассматривает несколько наиболее полезных из них.

Таблица 12-3. _Параметры, связанные с контролем времени запроса в очереди_

| Параметр | Доступные значения | Описание |
| :--- | :--- | :--- |
| announce-frequency | Значение в секундах | Определяет, как часто мы должны объявлять позицию вызывающего абонента и / или предполагаемое время удержания в очереди. Установите это значение на ноль, чтобы отключить. |
| min-announce-frequency | Значение в секундах | Указывает минимальное количество времени, которое должно пройти, прежде чем мы снова объявим позицию вызывающего абонента в очереди. Это используется, когда позиция вызывающего абонента может часто меняться, чтобы предотвратить прослушивание несколькими обновлениями за короткий промежуток времени.|
| periodic-announce-frequency | Значение в секундах | Указывает, как часто делать периодические объявления абоненту. |
| random-periodic-announce | yes, no | Если установлено значение `yes`, будут воспроизводиться определенные периодические объявления в случайном порядке. Смотрите `periodic-announce`. |
| relative-periodic-announce | yes, no | Если установлено значение `yes`,  `periodic-announce-frequency` таймер запустится, когда будет достигнут конец воспроизводимого файла, а не с самого начала. По умолчанию `no`. |
| announce-holdtime | yes, no, once | Определяет, следует ли воспроизводить расчетное время ожидания вместе с периодическими объявлениями. Может быть установлено значение `yes`, `no` или только один раз `once`. |
| announce-position | yes, no, limit, more | Определяет, следует ли объявлять им позицию вызывающего абонента в очереди. Если установлено значение `no`, позиция никогда не будет объявлена. Если установлено значение да, позиция вызывающего абонента всегда будет объявлена. Если задано значение `limit`, вызывающий абонент услышит свою позицию в очереди только в том случае, если она находится в пределах предела, определенного параметром `announce-position-limit`. Если задано значение больше, вызывающий абонент услышит свою позицию только в том случае, если она выходит за пределы номера, определенного параметром `announce-position-limit`. |
| announce-position-limit | Number of zero or greater | Используется, если вы определили объявленную позицию как `limit` или `more`. |
| announce-round-seconds | Значение в секундах | Если это значение отлично от нуля, число секунд также объявляется и округляется до определенного значения. |

Таблица 12-4 определяет файлы, которые будут использоваться при воспроизведении объявлений вызывающему абоненту.

Таблица 12-4. Параметры управления воспроизведением подсказок в очереди

| Параметр | Доступные значения | Описание |
| :--- | :--- | :--- |
| musicclass | Music class as defined by musiconhold.conf | Устанавливает музыкальный класс, который будет использоваться определенной очередью. Вы также можете переопределить это значение с помощью канальной переменной `CHANNEL` (musicclass). |
| queue-thankyou | Имя файла для воспроизведения | Если не определено, воспроизводится значение по умолчанию («Спасибо за ожидание»). Если установлено пустое значение, подсказка не будет воспроизводиться вообще. |
| queue-youarenext | Имя файла для воспроизведения |Если не определено, воспроизводится значение по умолчанию («Вы сейчас первый в очереди»). Если установлено пустое значение, подсказка не будет воспроизводиться вообще. |
| queue-thereare | Имя файла для воспроизведения | Если не определено, воспроизводится значение по умолчанию («Есть»). Если установлено пустое значение, подсказка не будет воспроизводиться вообще. |
| queue-callswaiting | Имя файла для воспроизведения | Если не определено, воспроизводится значение по умолчанию («ожидание вызова»). Если установлено пустое значение, подсказка не будет воспроизводиться вообще. |
| queue-holdtime | Имя файла для воспроизведения | Если не определено, воспроизводится значение по умолчанию («Текущее расчетное время ожидания»). Если установлено пустое значение, подсказка не будет воспроизводиться вообще. |
| queue-minutes | Имя файла для воспроизведения | Если не определено, воспроизводится значение по умолчанию («минут(ы)»). Если установлено пустое значение, подсказка не будет воспроизводиться вообще. |
| queue-seconds | Имя файла для воспроизведения | Если не определено, воспроизводится значение по умолчанию («секунд(ы)»). Если установлено пустое значение, подсказка не будет воспроизводиться вообще. |
| queue-reporthold | Имя файла для воспроизведения | Если не определено, воспроизводится значение по умолчанию («время ожидания»). Если установлено пустое значение, подсказка не будет воспроизводиться вообще. |
| periodic-announce | Набор периодических объявлений для воспроизведения, разделенных запятыми | Подсказки воспроизводятся в том порядке, в котором они определены. По умолчанию используется параметр `queue-periodic-announce` ("В настоящий момент все операторы заняты. Пожалуйста оставайтесь на линии и дождитесь свободного оператора"). |

Существует масса возможностей для гибкости при проектировании взаимодействия абонента во время ожидания, но, пожалуйста, не забывайте, что ваши абоненты никогда не будут счастливы ожидая в очереди. Кроме того, если вы нашли какую-то более-менее приличную музыку для MOH, и ваши абоненты наслаждаются ею, прерывание воспроизведения еще одним сообщением несёт риск по-настоящему вспенить их кровь. Когда абоненту наконец ответит участник очереди, он получит удар гнева, даже если это на самом деле ваша вина.<sup><a href="#sn5">5</a></sup>

Так что не нужно усложнять настройку удержания. Абоненты знают, что они ждут, и они не рады этому. Доставьте их агенту как можно быстрее, с минимальным количеством глупостей, пока они держатся, и не поддавайтесь искушению сделать очередь более важной для ваших абонентов, чем она есть на самом деле.

### Переполнение

К сожалению, ваша очередь не всегда будет своевременно доставлять ваших абонентов к агенту. Когда различные условия заставляют очередь отклонять входящих абонентов, мы имеем ситуацию переполнения. Переполнение очереди выполняется либо со значением таймаута, либо при отсутствии доступных членов очереди (как определено `joinempty` или `leavewhenempty`). В этом разделе мы обсудим, как контролировать возникновение переполнения.

#### Контроль времени ожидания

Приложение `Queue ()` поддерживает два вида тайм-аута: один определяет максимальный период времени, в течение которого вызывающий абонент находится в очереди, а другой - как долго следует звонить устройству при попытке подключить вызывающего абонента к участнику очереди. Эти парметры не связаны, но могут влиять друг на друга. В этом разделе мы будем говорить о максимальном периоде времени, в течение которого вызывающий абонент остается в приложении `Queue()` до того, как вызов переполнится, до следующего шага в диалплане, который может быть чем-то вроде `VoiceMail()` или даже другая очередь. После того, как вызов выпал из очереди, он может отправиться куда угодно, куда обычно может идти вызов, если он контролируется диалпланом.

Таймауты указываются в двух местах. Тайм-аут, указывающий, в течение какого времени звонить участникам очереди, указывается в таблице `queues`. Абсолютный тайм-аут (время пребывания абонента в очереди) контролируется с помощью приложения `Queue()`. Чтобы задать максимальное время пребывания абонентов в очереди, просто укажите его после имени очереди в приложении `Queue()`:
```
; Очередь
exten => 610,1,Noop()
   same => n,Progress()
   same => n,Queue(sales,120)
   same => n,Voicemail(${EXTEN}@queues,u)
   same => n,Hangup()
exten => 611,1,Noop()
   same => n,Progress()
   same => n,Queue(support,120)
   same => n,Voicemail(${EXTEN}@queues,u)
   same => n,Hangup()
exten => 612,1,Noop()
   same => n,Progress()
   same => n,Queue(support-priority,120)
   same => n,Voicemail(${EXTEN}@queues,u)
   same => n,Hangup()
```
Поскольку мы отправляем звонки на голосовую почту, нам понадобятся почтовые ящики:
```
MySQL> INSERT INTO `asterisk`.`voicemail`
(context,mailbox,password,fullname,email)

VALUES
('queues','610','192837','Queue sales','name@shifteight.org'),
('queues','611','192837','Queue support','name@shifteight.org'),
('queues','612','192837','Queue support-priority','name@shifteight.org');
```
Конечно, мы могли бы определить другое назначение, но приложение VoiceMail () является общим местом назначения переполнения для очереди. Очевидно, что отправка звонков на голосовую почту не идеальна (они надеялись поговорить с кем-то вживую), поэтому убедитесь, что кто-то регулярно проверяет это и перезванивает вашим клиентам.

Предположим, мы установили наше абсолютное время ожидания равным 10 секундам, наше значение времени ожидания для звонков участникам очереди равным 5 секундам,  а значение тайм-аута для повторной попытки - 4 секунды. В этом случае мы будем звонить участнику очереди в течение 5 секунд, а затем ждать 4 секунды, прежде чем пытаться запустить другого участника очереди. Это дает нам до 9 секунд нашего абсолютного тайм-аута в 10 секунд. Получается, мы должны позвонить второму участнику очереди в течение 1 секунды и затем выйти из очереди, или мы должны позвонить этому участнику в течение полных 5 секунд перед выходом?

Мы контролируем, какое значение тайм-аута имеет приоритет с помощью опции `timeoutpriority` в таблице` queues`. Доступные значения: `app` (по умолчанию) и `conf`. Если мы хотим, чтобы тайм-аут приложения (абсолютный тайм-аут) имел приоритет, что привело бы к тому, что наш абонент был исключен через ровно 10 секунд (даже если он только начинал звонить агенту), мы должны установить значение `timeoutpriority` в `app`. Если мы хотим, чтобы таймаут файла конфигурации имел приоритет и закончил звонить участнику очереди, что заставит абонента оставаться в очереди немного дольше, мы должны установить для `timeoutpriority` значение` conf`. Значением по умолчанию является `app` (по умолчанию в предыдущих версиях Asterisk). Вероятно, в большинстве случаев вы захотите использовать `conf` (особенно если вы хотите, чтобы опыт абонента был как можно менее странным).
```
MySQL> update `asterisk`.`queues` set timeoutpriority='conf'
  where name in ('sales','support','support-priority');
```
Цель состоит в том, чтобы доставить абонентов к агентам, да?

#### Управление временем присоединения и выхода из очереди

Asterisk предоставляет две опции, которые контролируют, когда вызывающие абоненты могут присоединиться и вынуждены покинуть очереди, обе на основе статусов участников очереди. Первая опция, `joinempty`, используется для контроля, могут ли абоненты входить в очередь в первую очередь. Вторая опция, `leftwhenempty`, используется для управления событиями, которые приведут к тому, что вызывающие абоненты, уже находящиеся в очереди, будут удалены из этой очереди (т.е. Если все члены очереди станут недоступными). Оба параметра допускают разделенный запятыми список значений для управления этим поведением, как показано в Таблице 12-5.

Таблица 12-5. _Параметры, которые можно установить для joinempty или leftwhenempty_

| Значение | Описание|
| :--- | :--- |
| paused | Участники считаются недоступными, если они приостановлены. |
| penalty | Участники считаются недоступными, если их пенальти меньше, чем` QUEUE_MAX_PENALTY`. |
| inuse | Участники считаются недоступными, если состояние их устройства `InUse`. |
| ringing | Участники считаются недоступными, если состояние их устройства `Ringing`. |
| unavailable | Применяется главным образом к каналам агента; если агент не вошел в систему, но является участником очереди, канал считается недоступным. |
| invalid | Участники считаются недоступными, если их статус устройства является `Invalid`. Это типичное условие ошибки. |
| unknown | Участники считаются недоступными, если состояние устройства `unknown`. |
| wrapup | Члены считаются недоступными, если они в настоящее время находятся в состоянии завершения после завершения вызова. |

Для `joinempty`, перед помещением вызывающего абонента в очередь, все участники проверяются на доступность, используя факторы, перечисленные в качестве критериев. Если все участники считаются недоступными, вызывающему абоненту не будет разрешено войти в очередь, и выполнение диалплана будет продолжено со следующим приоритетом.<sup><a href="#sn6">6</a></sup> Для опции `leavewhenempty` статусы участников периодически проверяются на соответствие перечисленным условиям; если выясняется, что ни один участник не доступен для приема вызовов, абонент удаляется из очереди, а выполнение диалплана продолжается со следующим приоритетом.

Примером использования `joinempty` может быть:
```
joinempty=unavailable,invalid,unknown
```
В этой конфигурации до того, как вызывающий абонент войдет в очередь, будут проверены состояния всех участников очереди, и вызывающему не будет разрешено войти в очередь, если по крайней мере один участник очереди не будет найден со статусом, который не является unavailable, invalid или unknown.

Примером `leavewhenempty` может быть что-то вроде:
```
leavewhenempty=unavailable,invalid,unknown
```
In this case, the queue members’ statuses will be checked periodically, and callers will be removed from the queue if no queue members can be found who do not have a status of unavailable, invalid, or unknown.

Previous versions of Asterisk used the values yes, no, strict, and loose as the available values to be assigned. The mapping of those values is shown in Table 12-6

Table 12-6. Mapping between old and new values for controlling when callers join and leave queues

| Value | Mapping (joinempty) | Mapping (leavewhenempty) |
| :--- | :--- | :--- |
| yes | (empty) | penalty,paused,invalid |
| no | penalty,paused,invalid | (empty) |
| strict | penalty,paused,invalid,unavailable | penalty,paused,invalid,unavailable |
| loose | penalty,invalid | penalty,invalid |

### Using Local Channels

The use of local channels as queue members is a powerful way of executing dialplan code prior to dialing the actual agent’s device. When Queue() decides to present a call to an agent, using local channels allows us to define custom channel variables, write to a logfile, set some limit on call length (e.g., if it is a paid service), send messages of all sorts all over the place, perform database transactions, and perform many of the other actions we might wish to do at that exact moment. Normally, we have no control over when the Queue() application has decided to present a caller to a specific member, but with local channels, we get one final kick at the can, and can even return Congestion(), which will have the effect of returning the caller to the queue, since the queue will not consider this call to have been successfully delivered to an agent (this can be very handy, since some external condition can be evaluated before the call is just fired off to an endpoint).

When using local channels for queues, they are added just like any other channels, typically dynamically through the AddQueueMember() dialplan application.

We’ll need to define the local channel where all the magic happens, and since local channels are typically used in a manner similar to subroutines, we like to name and locate them in the dialplan with the subroutines, with a context name starting with local (akin to how subroutines start with sub). If you’ve been building out your dialplan along with the book, you’ll notice you already have a local channel [localDialDelay]. Add this code somewhere in that part of the dialplan.

[localMemberConnector]

exten => _[A-Za-z0-9].,1,Verbose(2,Connect ${CALLERID(all)} to Agent at ${EXTEN})

 ; filter out any bad characters, allow alphanumeric chars and hyphen

 same => n,Set(QueueMember=${FILTER(A-Za-z0-9-,${EXTEN})})

 ; assign the first field of QueueMember to Technology; hyphen as separator

 same => n,Set(Technology=${CUT(QueueMember,-,1)})

 ; assign the second field of QueueMember to Device using the hyphen separator

 same => n,Set(Device=${CUT(QueueMember,-,2)})

 ; dial the agent

 same => n,Dial(${Technology}/${Device})

 same => n,Hangup()

This code might not make total sense just yet, but what it’s doing is taking the ${EXTEN} (which is a complex alphanumeric string at this point), and slicing and dicing it to extract the actual channel to be called (i.e., we pass as part of the local channel all the information needed to dial the actual channel).

Let’s look at the AddQueueMember code and see if we can make more sense of this:

exten => *740,1,Noop(Logging in device ${CHANNEL(endpoint)} into the support queue)

 same => n,Set(MemberTech=${CHANNEL(channeltype)})

 same => n,Set(MemberIdent=${CHANNEL(endpoint)})

 same => n,Set(Interface=${MemberTech}/${MemberIdent})

 ;;; THE FOLLOWING SHOULD ALL BE ON ONE LINE

same => n,AddQueueMember(support,Local/${MemberTech}-${MemberIdent}@localMemberConnector

,,,${IF($[${MemberTech} = PJSIP]?${Interface})})

 same => n,Playback(silence/1)

 same => n,Playback(${IF($[${AQMSTATUS} = ADDED]?agent-loginok:agent-incorrect)})

 same => n,Hangup()

Once you’ve input all this and reloaded your dialplan, log into the queue by dialing *740, and let’s see what we’ve got.

*CLI> queue show support

support has 0 calls (max unlimited) in 'rrmemory' strategy (1s holdtime, 0s talktime),

W:0, C:1, A:1, SL:0.0%, SL2:0.0% within 0s

 Members:

 PJSIP/SOFTPHONE_A (Local/PJSIP-SOFTPHONE_A@localMemberConnector)

(ringinuse disabled) (dynamic) (Not in use)

 No Callers

The member is now identified to the queue as a local channel named PJSIP-SOFTPHONE_A in the [localMemberConnector] context. (The PJSIP/SOFTPHONE_A channel will be monitored for actual status of the endpoint.) When Queue() decides to send a call to the member, the call will end up in the [localMemberConnector] context, where the EXTEN (PJSIP-SOFTPHONE_A) will be sliced and diced in order to yield our channel type and endpoint,[7](https://learning.oreilly.com/library/view/asterisk-the-definitive/9781492031598/ch12.html%22%20/l%20%22idm46178405718440) which is what will actually be called.

At this point, the purpose of all this extra complexity is not immediately clear. So far we don’t get anything useful out of all this extra code.

So now that we can add devices to the queue using local channels, let’s look at how this might be useful.

Let’s say we have a customer who just can’t stand our best agent. They’re a good customer, so we don’t want to lose them, but it’s our best agent, so we’re not going to fire them.

To set this up, we’re going to assign a caller ID to SOFTPHONE_B, so we have something to match against.

MySQL> UPDATE `asterisk`.`ps_endpoints` SET callerid='SOFTPHONE_B &lt;103>' 

WHERE id='SOFTPHONE_B';

We’re going to build a little trick into our dialplan that will reject the call to the agent if the caller ID matches our sensitive customer.

[localMemberConnector]

exten => _[A-Za-z0-9].,1,Verbose(2,Connect ${CALLERID(all)} to Agent at ${EXTEN})

 same => n,Wait(0.1) ; Prevent loop from completely hogging CPU

 same => n,Set(QueueMember=${FILTER(A-Za-z0-9-_,${EXTEN})}) ; allow alphanum, - , _

 same => n,Set(Technology=${CUT(QueueMember,-,1)}) ; first field, hyphen is separator

 same => n,Set(Device=${CUT(QueueMember,-,2)}) ; second field, hypen separator

 ; is this our mismatched pair?

 same => n,DumpChan()

 same => n,Noop(${CALLERID(all)} : ${Device})

same=>n,GotoIf($["${CALLERID(num)}"="103"&"${Device}"="SOFTPHONE_A"]?rejectcall:ringagent)

 ; dial the agent

 same => n(ringagent),Dial(${Technology}/${Device})

 same => n,Hangup()

 ; send it back!

 same => n(rejectcall),Congestion()

 same => n,Hangup()

The passing back of Congestion() will cause the caller to be returned to the queue (while this is happening, the caller gets no indication that anything is amiss and keeps hearing music until their call is answered by a channel of some sort).[8](https://learning.oreilly.com/library/view/asterisk-the-definitive/9781492031598/ch12.html%22%20/l%20%22idm46178405708120) Ideally, your queue is programmed to try another agent; however, you need to keep in mind that if app_queue determines that this member is still its first choice to present the call to, the call will simply be reconnected to the same agent (and get congestion again, and thus potentially create a CPU-hogging logic loop). To avoid this, you will need to ensure your queue is using a distribution strategy such as round_robin, random, or any strategy that ensures the same member is not tried over and over. This is also why we toss a tiny little delay into our [localMemberConnector] context, so if a loop like this does happen, there’s at least a small throttle on it.

Let’s just sanity check our code. Set the caller ID number to something other than 103, and the call should go through.

MySQL> UPDATE `asterisk`.`ps_endpoints` SET callerid='SOFTPHONE_B &lt;123>' 

WHERE id='SOFTPHONE_B';

The use of local channels for your member channels will not make queue design and debugging easier, but it does give you far more power over your queues than just using app_queue on its own, so if you have a complex queue requirement, the use of local channels will give you a level of control you would not have otherwise.

## Queue Statistics: The queue_log File

The queue_log file (commonly located in /var/log/asterisk) contains cumulative event information for the queues defined in your system (such as when a queue is reloaded, when queue members are added or removed, pause/unpause events, and so forth) as well as some call details (e.g., their status and which channels the callers were connected to). The queue log is enabled by default, but it can be controlled via the /etc/asterisk/logger.conf file. There are three options related to the queue_log file specifically:

queue_log

Controls whether the queue log is enabled or not. Valid values are yes or no (defaults to yes).

queue_log_to_file

Controls whether the queue log should be written to a file even when a real-time backend is present. Valid values are yes or no (defaults to no).

queue_log_name

Controls the name of the queue log. The default is queue_log.

The queue log is a pipe-separated list of events. The fields in the queue_log file are as follows:

* UNIX Epoch timestamp of the event
* Unique ID of the call
* Name of the queue
* Name of bridged channel
* Type of event
* Zero or more event parameters

The information contained in the event parameters depends on the type of event. A typical queue_log file will look something like the following:

1530389309|NONE|NONE|NONE|QUEUESTART|

1530409313|CLI|support|PJSIP/SOFTPHONE_B|ADDMEMBER|

1530409467|CLI|support|PJSIP/SOFTPHONE_B|REMOVEMEMBER|

1530409666|NONE|support|PJSIP/SOFTPHONE_B|PAUSE|Callbacks

1530411108|NONE|support|PJSIP/SOFTPHONE_B|UNPAUSE|FinishedCallbacks

1530440239|1530440239.10|support|PJSIP/SOFTPHONE_A|ADDMEMBER|

1530440303|1530440303.16|support|PJSIP/SOFTPHONE_A|REMOVEMEMBER|

1530497165|1530497165.54|support|Local/PJSIP-SOFTPHONE_A@MemberConnector|ADDMEMBER|

1530497388|CLI|support|Local/PJSIP-SOFTPHONE_A@MemberConnector|REMOVEMEMBER|

1530497408|1530497408.60|support|Local/PJSIP-SOFTPHONE_A@localMemberConnector|ADDMEMBER|

1530497506|1530497506.71|support|NONE|ENTERQUEUE||SOFTPHONE_B|1

1530497511|1530497506.71|support|PJSIP/SOFTPHONE_A|CONNECT|5|1530497506.72|4

1530497517|1530497506.71|support|PJSIP/SOFTPHONE_A|COMPLETEAGENT|5|6|1

1530509861|1530509861.134|support|NONE|ENTERQUEUE||SOFTPHONE_B|1

1530509864|1530509861.134|support|PJSIP/SOFTPHONE_A|RINGCANCELED|2224

1530509864|1530509861.134|support|NONE|ABANDON|1|1|3

1530510503|1530510503.156|support|NONE|ENTERQUEUE||103|1

1530510503|1530510503.156|support|PJSIP/SOFTPHONE_A|RINGNOANSWER|0

1530510511|1530510503.156|support|NONE|ABANDON|1|1|8

1530510738|1530510738.163|support|NONE|ENTERQUEUE||123|1

1530510742|1530510738.163|support|PJSIP/SOFTPHONE_A|CONNECT|4|1530510738.164|4

1530510752|1530510738.163|support|PJSIP/SOFTPHONE_A|COMPLETECALLER|4|10|1

As you can see from this example, there may not always be a unique ID for the event. External services, such as the Asterisk CLI, can perform actions on the queue, and in these cases you’ll see something like CLI in the Unique ID field.

The available events and the information they provide are described in [Table 12-7](Asterisk%20%20The%20Definitive%20Guide,%205th%20Edition/12.%20Automatic%20Call%20Distribution%20Queues%20-%20Asterisk%20%20The%20Definitive%20Guide,%205th%20Edition.htm%22%20/l%20%22ACD_id289031).

Table 12-7. Events in the Asterisk queue log

| Event | Information provided |
| :--- | :--- |
| ABANDON | Written when a caller in a queue hangs up before his call is answered by an agent. Three parameters are provided for ABANDON: the position of the caller at hangup, the original position of the caller when entering the queue, and the amount of time the caller waited prior to hanging up. |
| ADDMEMBER | Written when a member is added to the queue. The bridged channel name will be populated with the name of the channel added to the queue. |
| AGENTDUMP | Indicates that the agent hung up on the caller while the queue announcement was being played, prior to them being bridged together. |
| AGENTLOGIN | Recorded when an agent logs in. The bridged channel field will contain something like Agent/9994 if logging in with chan_agent, and the first parameter field will contain the channel logging in (e.g., SIP/0000FFFF0001). |
| AGENTLOGOFF | Logged when an agent logs off, along with a parameter indicating how long the agent was logged in for. Note that since you will often use RemoveQueueMember() for agent log off, this parameter may not be written. See the REMOVEMEMBER event instead. |
| COMPLETEAGENT | Recorded when a call is bridged to an agent and the agent hangs up, along with parameters indicating the amount of time the caller was held in the queue, the length of the call with the agent, and the original position at which the caller entered the queue. |
| COMPLETECALLER | Same as COMPLETEAGENT, except the caller hung up and not the agent. |
| CONFIGURELOAD | Indicates that the queue configuration was reloaded (e.g., via module reload app_queue.so). |
| CONNECT | Written when the caller and the agent are bridged together. Three parameters are also written: the amount of time the caller waited in the queue, the unique ID of the queue member’s channel to which the caller was bridged, and the amount of time the queue member’s phone rang prior to being answered. |
| ENTERQUEUE | Written when a caller enters the queue. Two parameters are also written: the URL (if specified) and the caller ID of the caller. |
| EXITEMPTY | Written when the caller is removed from the queue due to a lack of agents available to answer the call (as specified by the leavewhenempty parameter). Three parameters are also written: the position of the caller in the queue, the original position at which the caller entered the queue, and the amount of time the caller was held in the queue. |
| EXITWITHKEY | Written when the caller exits the queue by pressing a single DTMF key on his phone to exit the queue and continue in the dialplan (as enabled by the context parameter in queues.conf). Four parameters are recorded: the key used to exit the queue, the position of the caller in the queue upon exit, the original position the caller entered the queue at, and the amount of time the caller was waiting in the queue. |
| EXITWITHTIMEOUT | Written when the caller is removed from the queue due to timeout, as specified by the timeout parameter to Queue(). Three parameters are also recorded: the position the caller was in when exiting the queue, the original position of the caller when entering the queue, and the amount of time the caller waited in the queue. |
| PAUSE | Written when a queue member is paused. |
| PAUSEALL | Written when all members of a queue are paused. |
| UNPAUSE | Written when a queue member is unpaused. |
| UNPAUSEALL | Written when all members of a queue are unpaused. |
| PENALTY | Written when a member’s penalty is modified. The penalty can be changed through several means, such as the QUEUE_MEMBER_PENALTY() function, the Asterisk Manager Interface, or the Asterisk CLI commands. |
| REMOVEMEMBER | Written when a queue member is removed from the queue. The bridge channel field will contain the name of the member removed from the queue. |
| RINGNOANSWER | Logged when a queue member is rung for a period of time, and the timeout value for ringing the queue member is exceeded. A single parameter will also be written indicating the amount of time the member’s extension rang. |
| TRANSFER | Written when a caller is transferred to another extension. Additional parameters are also written, which include the extension and context the caller was transferred to, the hold time of the caller in the queue, the amount of time the caller was speaking to a member of the queue, and the original position of the caller when he entered the queue.<sup><a href="#sn9">9</a></sup> |
| SYSCOMPAT | Recorded if an agent attempts to answer a call, but the call cannot be set up due to incompatibilities in the media setup. |


## Вывод

Мы начали эту главу с рассмотрения основных очередей вызовов, обсуждения того, что они из себя представляют, как они работают и когда вы, возможно, захотите их использовать. После построения простой очереди мы изучили, как управлять участниками очереди с помощью различных средств (включая использование локальных каналов, которые обеспечивают возможность выполнения некоторой логики набора номеров непосредственно перед подключением к участнику очереди). Конечно, нам нужна возможность отслеживать, что делают наши очереди, поэтому мы быстро просмотрели файл _queue_log_ и различные поля, записанные в результате событий, происходящих в наших очередях.

Благодаря информации, представленной в этой главе, вы обладаете большинством базовых знаний, необходимых для реализации очередей в Asterisk.

---

<ol>
<li id="sn1"> Это распространенное заблуждение, что очередь может позволить вам обрабатывать больше вызовов. Это не совсем верно: ваши абоненты все равно захотят поговорить с живым человеком, и они будут только ждать так долго. Другими словами, если у вас мало сотрудников, ваша очередь может оказаться не более чем препятствием для ваших абонентов. Это то же самое, говорите ли вы по телефону или на кассе Walmart. Никто не любит ждать в очереди. Идеальная очередь невидима для звонящих, так как на их звонки отвечают сразу, без ожидания.</li>
<li id="sn2"> Существует несколько книг, в которых обсуждаются метрики колл-центра и доступные стратегии организации очередей, например, «Руководство по метрикам колл-центра» Джеймса Эббота (Роберт Хьюстон Смит).</li>
<li id="sn3"> Мы собираемся использовать символ ^ в качестве разделителя. Возможно, вы могли бы использовать вместо этого другой символ, только если он не тот, который синтаксический анализатор Asterisk будет рассматривать как обычный разделитель (и, таким образом, будет сбит с толку). Поэтому избегайте запятых, точек с запятой и так далее.</li>
<li id="sn4"> Похоже на добавление балласта к жокею или гоночному автомобилю.</li>
<li id="sn5"> Просто говорю'.</li>
<li id="sn6"> Если приоритет <code>n+1</code> (откуда было вызвано приложение <code>Queue()</code>) не определен, вызов будет прерван. Другими словами, не используйте эту функцию, если ваш диалплан не делает что-то полезное на шаге, следующем сразу за <code>Queue()</code>.</li>

[7](https://learning.oreilly.com/library/view/asterisk-the-definitive/9781492031598/ch12.html%22%20/l%20%22idm46178405718440-marker) Perhaps we could have used / instead of - as a delimiter, giving us Local/PJSIP/SOFTPHONE_A@localMemberConnector, but we felt that would be more prone to strange syntax errors, and awkward to filter and parse, so we went with -.</li>

[8](https://learning.oreilly.com/library/view/asterisk-the-definitive/9781492031598/ch12.html%22%20/l%20%22idm46178405708120-marker) Obviously, don’t use any dialplan code in your local channel that will answer, such as Answer(), Playback(), and so forth.</li>

<li id="sn9"> Обратите внимание, что при передаче вызывающего абонента с использованием SIP-передач (а не встроенных передач, запускаемых DTMF и настраиваемых в <i>features.conf</i>), событие TRANSFER может не записываться.</li>
</ol>

[Глава 11. Функции АТС, включая парковку, пейджинг и конференц-связь](glava-11.md) | [Содержание](SUMMARY.md) | [Глава 13. Состояния устройств](glava-13.md)