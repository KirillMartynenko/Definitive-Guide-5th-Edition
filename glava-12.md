# Глава 12. Автоматические очереди распределения вызовов

## Глава 12. Очереди автоматического распределения вызовов

>Англичанин, даже если он один, формирует упорядоченную очередь из одного человека.
>
>-- Джордж Майкс

Автоматическое распределение вызовов (ACD), или организация очереди вызовов, позволяет УАТС ставить в очередь входящие вызовы от нескольких пользователей. Он объединяет несколько вызовов в шаблон удержания, присваивает каждому вызову рейтинг и определяет порядок, в котором этот вызов должен быть доставлен доступному оператору (как правило, сначала в порядке очереди). Когда агент становится доступным, вызывающий абонент с самым высоким рейтингом в очереди доставляется этому агенту, а все остальные повышаются в рейтинге.

Если вы когда-либо звонили в организацию и слышали, что «все наши представители заняты», вы испытали ACD. Преимущество ACD для вызывающих абонентов в том, что им не нужно продолжать набирать номер в попытке связаться с кем-то, а преимущества для организаций заключаются в том, что они могут лучше обслуживать своих клиентов и решать проблему, когда звонящих больше, чем агентов.<sup><a href="#sn1">1</a></sup>

**Примечание**

Существует два типа колл-центров: входящие и исходящие. ACD относится к технологии, которая обрабатывает центры обработки входящих вызовов, тогда как термин _Dialer_ (или _Predictive Dialer_) относится к технологии, которая обрабатывает центры обработки исходящих вызовов. В этой книге мы прежде всего сосредоточимся на входящих звонках.

Мы все были разочарованы плохо спроектированными и управляемыми очередями: длительное удержание, радио вместо мелодии, ошеломляющее время ожидания и бессмысленные сообщения, которые каждые 20 секунд сообщают вам, насколько важен ваш звонок, несмотря на то, что вы ждали 30 минут и прослушали это сообщение так много раз, что можете процитировать его по памяти. С точки зрения обслуживания клиентов, дизайн очереди может быть одним из наиболее важных аспектов вашей телефонной системы. Как и в случае с автосекретарем, прежде всего следует помнить, что _ваши абоненты не заинтересованы в том, чтобы стоять в очереди_. Они позвонили, потому что _хотят с Вами поговорить_. Все ваши дизайнерские решения должны помнить об этом важном факте: люди хотят общаться с другими людьми, а не с Вашей телефонной системой.<sup><a href="#sn2">2</a></sup>

Цель этой главы - научить вас, как создавать и проектировать очереди, которые доставляют абонентов по назначению максимально быстро и безболезненно.

**Примечание**

В этой главе мы можем переключаться между использованием терминов _queue members_ и _agents_. Так как мы не собираемся тратить много времени на модуль Asterisk с именем `chan_agent` (используя `AgentLogin()`), нам нужно прояснить, что в этой книге, когда мы используем термин _agent_, имеется в виду конечный пользователь - человек, а не канальная технология в Asterisk с именем `chan_agent`. Читайте дальше, и это обретёт больше смысла.

## Создание простой очереди ACD

Для начала мы собираемся создать простую очередь ACD. Она будет принимать звонящих и пытаться доставить их участнику очереди.

**Примечание**

В Asterisk термин _member_ относится к каналу (обычно одноранговому узлу SIP), назначенному очереди, которую можно набрать, например, `SIP/0000FFFF0001`. _agent_ технически относится к каналу агента, также используемому для набора конечных точек. К сожалению, канал агента является устаревшей технологией в Asterisk, так как он ограничен в гибкости и может вызвать непредвиденные проблемы, которые трудно диагностировать и разрешать. Мы не будем охватывать использование `change_agent`, поэтому имейте в виду, что мы будем использовать термин `member`(участник) для обозначения телефонного устройства и `agent` (агент) для обозначения лица, которое обрабатывает вызов. Поскольку один из них, как правило, не эффективен без другого, любой термин может относиться к обоим.

Мы создадим очередь(и) в файле _queues.conf_ и добавим в нее участников очереди через консоль Asterisk. В разделе “Участники Очереди” мы рассмотрим, как создать абонентскую группу, которая позволяет нам динамически добавлять и удалять участников очереди (а также приостанавливать и возобновлять их).

Первым шагом является создание пустого файла _agents.conf_ в вашем каталоге конфигурации _/etc/asterisk_. Мы не будем использовать или редактировать этот файл, но модуль `app_queue` ожидает его нахождения и не будет загружаться, если файл не существует:

```
$ cd /etc/asterisk
$ sudo -u asterisk touch agents.conf
```
Поскольку мы еще не сделали этого, мы также собираемся настроить базовую музыку в режиме ожидания (MOH), используя файл примера:
```
$ sudo cp ~/src/asterisk-16.*/configs/samples/musiconhold.conf.sample /etc/asterisk/musiconhold.conf

$ sudo chown asterisk:asterisk /etc/asterisk/musiconhold.conf
```
Затем вам нужно создать файл _queues.conf_, но мы не будем его редактировать, потому что мы будем создавать наши очереди в базе данных (файл просто должен быть там):
```
$ sudo touch -u asterisk queues.conf
```
Далее мы создадим несколько очередей в нашей базе данных:
```
MySQL>; INSERT INTO `asterisk`.`queues`

(name,strategy,joinempty,leavewhenempty,ringinuse,autofill,musiconhold, 
monitor_format,monitor_type)

VALUES
'sales','rrmemory','unavailable,invalid,unknown','unavailable,invalid,unknown','no','yes',
'default','wav','MixMonitor'),
('support','rrmemory','unavailable,invalid,unknown','unavailable,invalid,unknown','no',
'yes','default','wav','MixMonitor') ;
```
Это даст нам две очереди, названные `sales` и `support`. Вы можете называть их как угодно, но мы будем использовать эти имена позже в этой книге, поэтому, если вы используете имена очередей, отличные от тех, которые мы использовали здесь, запомните или запишите ваши названия для дальнейшего использования.

Мы также определили параметры очередей, изложенные в Таблице 12-1.

Таблица 12-1. _Примерные параметры очереди_

| Parameter | Purpose |
| :--- | :--- |
| `strategy=rrmemory` | Используйте стратегию кругового перебора с памятью |
| `joinempty=unavailable,invalid,unknown` | Не присоединятся к очереди, когда нет доступных участников |
| `leavewhenempty=unavailable,invalid,unknown` | Покинуть очередь, когда нет доступных участников |
| `ringinuse=no` | Не звонить участникам, когда они уже используются (предотвращает многократные звонки участникам)|
| `autofill=yes` | Распределить всех ожидающих абонентов среди доступных участников |
| `musiconhold=default` | Воспроизведение музыки из класса `[default]` (см. <code>musiconhold.conf</code>) |

`strategy`, которую мы будем использовать, - это `rrmemory`, что означает круговой перебор с памятью. Стратегия `rrmemory` работает путем чередования агентов в очереди в последовательном порядке, отслеживая, какой агент получил последний вызов, и предоставляя следующий вызов следующему агенту. Когда он попадает к последнему агенту, он возвращается к началу (при входе агентов они добавляются в конец списка).
##
**Несколько примечаний по  Стратегиям**

`ringall`

Звонит всем доступным участникам (по умолчанию). Эта стратегия распределения на самом деле не считается ACD. В традиционных терминах телефонии это называется "групповой вызов" (_ring group_).

`leastrecent`

Каждый следующий звонок будет получать участник, который в последний раз положил трубку раньше всех остальных. В очереди, где есть много вызовов примерно одинаковой продолжительности, это справедливо.  Но это не будет справеливым, если агент был на вызове в течение часа а все его коллеги получили последний звонок 30 минут назад,потому что агент, который закончил последним свой 60-минутный вызов получит следующий звонок.

`fewestcalls`

Вызывается первый свободный участник, который обработал наименьшее количество вызовов из данной очереди. Это может быть несправедливо, если звонки не всегда имеют одинаковую продолжительность. Агент мог обрабатывать три звонка по 15 минут каждый, а его коллега имел четыре 5-секундных звонка; агент, который обработал три звонка, получит следующий звонок.

`random`

Звонит случайный интерфейс. Это на самом деле может быть хорошо и в конечном итоге будет очень справедливым с точки зрения равномерного распределения вызовов между агентами.

`rrmemory`

Обзванивает участников по кругу, запоминается последний участник, ответивший на вызов. Это также может быть справедливым, но не так как `random`.

`linear`

Звонит участникам в указанном порядке, всегда начиная с начала списка. Это работает, если у вас есть команда, в которой есть некоторые агенты, которые должны обрабатывать большинство вызовов, и другие агенты, которые должны получать вызовы, только если  основные агенты заняты.

`wrandom`

Звонит случайному участнику, но использует пенальти `penalty` (ударение на первую букву "е") участников в качестве веса `weight`. Стоит рассмотреть в очередях с большой нагрузкой  cреди агентов.
##
Мы установили `joinempty` на `no`, так как ставить абонентов в очередь, где нет доступных агентов чтобы принимать их звонки это плохо.

**Примечание**

Вы можете установить это значение в `yes` для удобства тестирования, но мы не рекомендуем запускать его в производство, если вы не используете очередь для какой-либо функции, которая не предназначена для передачи абонентов вашим агентам. Никто не хочет ждать в очереди, которая никуда не идет.

Опция `leavewhenempty` используется для управления тем, должны ли абоненты выпадать из приложения `Queue()` и продолжать работу в диалплане, если ни один из участников не может принимать их вызовы. Мы установили это значение на `yes`, потому что обычно вы не хотите, чтобы абоненты ждали в очереди без зарегистрированных агентов.

**Примечание**

С точки зрения бизнеса, вы должны сказать своим агентам, чтобы они очистили все звонки из очереди, прежде чем выходить из системы в течение дня. Если вы обнаружите, что в конце дня в очереди много вызовов, возможно, вы захотите продлить чью-то смену, чтобы обслужить их. В противном случае, они просто добавят вам стресса, когда перезвонят на следующий день в худшем настроении.

Вы можете использовать `GotoIfTime()` ближе к концу дня, чтобы перенаправить абонентов на голосовую почту или другое подходящее место в вашем диалплане, пока ваши агенты очищают все оставшиеся вызовы в очереди.

Мы будем ставить `ringinuse` на `no`, что говорит Asterisk не звонить участникам, когда их устройства уже используются. Целью установки `ringinuse` в `no` является предотвращение многократных вызовов одного и того же участника из одной или нескольких очередей.

**Примечание**

Следует отметить, что упомянутые `joinempty` и `leftwhenempty` ищут либо участников, не вошедших в очередь, либо недоступных участников. Агенты, которые являются `Ringing` или `InUse`, не считаются недоступными, поэтому не будут блокировать абонентов от присоединения к очереди и заставлять их отключаться, когда `joinempty=no` и/или `leftwhenempty=yes`.

Опция `autofill` указывает очереди немедленно распределить всех ожидающих абонентов между всеми доступными участниками. Предыдущие версии Asterisk распределяли только одного абонента за один раз, что означало, что в то время как Asterisk подавал сигнал агенту, все остальные вызовы удерживались (даже если другие агенты были доступны) до тех пор, пока первый абонент в очереди не был подключен к агенту (что, очевидно, приводило к узким местам в старых версиях Asterisk, где использовались занятые очереди). Если у вас нет особой потребности в обратной совместимости, _этот параметр всегда_ должен быть установлен в `yes`.

Убедитесь, что ваш файл _/etc/asterisk/extconfig_ содержит следующие строки:
```
queues => odbc,asterisk,queues
queue_members => odbc,asterisk,queue_members
```
Сохраните и перезагрузите конфигурацию очереди из интерфейса командной строки Asterisk CLI:
```
*CLI> queues reload
```
Убедитесь, что ваши очереди были загружены в память (не забудьте убедиться, что файл _agents.conf_ существует:
```
localhost*CLI> queue show
support has 0 calls (max unlimited) in 'rrmemory' strategy
(0s holdtime, 0s talktime), W:0, C:0, A:0, SL:0.0% within 0s
 No Members
 No Callers

sales has 0 calls (max unlimited) in 'rrmemory' strategy
(0s holdtime, 0s talktime), W:0, C:0, A:0, SL:0.0% within 0s
 No Members
 No Callers
```
Выходные данные `queue show` предоставляют различную информацию, в том числе детали, подробно описанные в Таблице 12-2.

Таблица 12-2. _Описание вывода queue show_

| Field | Description |
| :--- | :--- |
| W: | Вес очереди |
| C: | Количество вызовов в очереди |
| A: | Количество звонков, на которые ответил участник |
| SL: | Уровень обслуживания |

Теперь, когда вы создали очереди, вам нужно настроить диалплан так, чтобы звонки могли входить в очередь.

Добавьте следующую логику плана набора в файл _extensions.conf_ (где-нибудь в контексте `[sets]`):
```
exten => 610,1,Noop()
 same => n,Progress()
 same => n,Queue(sales)
 same => n,Hangup()

exten => 611,1,Noop()
 same => n,Progress()
 same => n,Queue(support)
 same => n,Hangup()
```
Сохраните изменения в файле extensions.conf и перезагрузите план набора с помощью команды CLI перезагрузки `dialplan reload`.

Если вы наберете добавочный номер 610 или 611, вы получите следующий вывод:
```
== Setting global variable 'SIPDOMAIN' to '172.29.1.178'
-- Executing [610@sets:1] NoOp("PJSIP/SOFTPHONE_A-00000004", "") in new stack
-- Executing [610@sets:2] Progress("PJSIP/SOFTPHONE_A-00000004", "") in new stack
-- Executing [610@sets:3] Queue("PJSIP/SOFTPHONE_A-00000004", "test") in new stack
   > 0x7facc801ed60 -- Strict RTP learning after remote set to: 172.29.1.166:4022
-- Started music on hold, class 'testmoh', on channel 'PJSIP/SOFTPHONE_A-00000004'
   > 0x7facc801ed60 -- Strict RTP switching to RTP target 172.29.1.166:4022 as source
   > 0x7facc801ed60 -- Strict RTP learning complete - Locking on 172.29.1.166:4022
-- Stopped music on hold on PJSIP/SOFTPHONE_A-00000004
== Spawn extension (sets, 610, 3) exited non-zero on 'PJSIP/SOFTPHONE_A-00000004'
```
Обратите внимание, что в этот момент вы не присоединитесь к очереди, потому что в очереди нет агентов для ответа на вызовы. У нас настроены `joinempty=no` и `leftwhenempty=yes`, поэтому вызывающие не будут помещаться в очередь. (Это была бы хорошая возможность поэкспериментировать с опциями `joinempty` и `leftwhenempty` в _queues.conf_, чтобы лучше понять их влияние на очереди)

В следующем разделе мы покажем, как добавлять участников в очередь (а также другие взаимодействия участников с очередью, такие как пауза/отмена паузы).

## Участники очереди

Очереди не очень полезны, если кто-то не отвечает на входящие вызовы, поэтому нам нужен метод, позволяющий агентам входить в очереди для ответа на вызовы. Существуют различные способы решения этой задачи, поэтому мы покажем вам, как добавлять участников в очередь как вручную (как администратор, через CLI или жестко прописанную в таблице `queue_members`), так и динамически (в качестве агента через расширение, определенное в диалплане). Мы начнем с метода Asterisk CLI, который позволяет легко добавлять участников в очередь для тестирования с минимальными изменениями плана набора. Далее мы покажем, как вы можете определить участников в таблице `queue_members`. Наконец, мы покажем вам, как добавить логику диалплана, которая позволяет агентам входить в очереди и выходить из них, а также приостанавливать и возобновлять себя в очередях, в которые они вошли (это, вероятно, лучший метод для производства).

### Управление участниками очереди через CLI

Мы можем добавить членов очереди в любую доступную очередь через команду очереди Asterisk CLI `queue add`. Формат команды добавления очереди `queue add` (все в одной строке):
<pre>
 <code style="font-size:12px">
  *CLI> queue add member <i>channel</i> to queue [[[penalty <i>penalty</i>] as <i>membername</i>]state_interface <i>interface</i>]
 </code>
</pre>
`channel` - это канал, который мы хотим добавить в очередь, например SIP/0000FFFF0003, а имя `queue` будет что-то вроде `support` или `sales` - любое имя очереди, которое существует в _/etc/asterisk/queues.conf_. Пока мы будем игнорировать вариант c `penalty`, но мы обсудим его в разделе «Расширенные очереди» (`penalty` используется для контроля ранга участника в очереди, что может быть важно для операторов, которые вошли в несколько очередей или имеют разные навыки). Мы можем определить `membername`, чтобы предоставить подробные сведения для механизма регистрации очередей.

Опция `state_interface` информирует очередь о состоянии устройства, которое будет отслеживаться для этого агента. Детали работы с состояниями устройства обсуждаются в [Главе 13](glava-13.md). Сходите и проработайте эту главу, а затем вернитесь сюда и продолжайте. Не волнуйся, мы подождем.

Теперь, когда вы добавили `callcounter=yes` в _sip.conf_ (мы будем использовать SIP-каналы во всех остальных наших примерах), давайте посмотрим, как добавлять участников в наши очереди из Asterisk CLI.

Добавление участника очереди в очередь `support` можно выполнить с помощью команды `queue add member`:
```
*CLI> queue add member PJSIP/SOFTPHONE_B to support

Added interface 'PJSIP/SOFTPHON_B' to queue 'support'
```
Запрос очереди подтвердит, что наш новый участник был добавлен:
```
*CLI> queue show support

support has 0 calls (max unlimited) in 'rrmemory' strategy (0s holdtime, 0s talktime),
W:0, C:0, A:0, SL:0.0%, SL2:0.0% within 0s
    Members:
        PJSIP/SOFTPHONE_B (ringinuse disabled) (dynamic)(Not in use) has taken no calls yet
    No Callers
```
Чтобы удалить участника очереди, вы должны использовать команду `queue remove member`:
```
*CLI> queue remove member PJSIP/SOFTPHONE_B from support

Removed interface PJSIP/SOFTPHONE_B from queue 'support'
```
Конечно, вы можете снова использовать команду `queue show`, чтобы убедиться, что ваш участник был удален из очереди:
```
*CLI> queue show support

support has 0 calls (max unlimited) in 'rrmemory' strategy (0s holdtime, 0s talktime),
W:0, C:0, A:0, SL:0.0%, SL2:0.0% within 0s
   Members:
      PJSIP/SOFTPHONE_B (ringinuse disabled) (dynamic) (Not in use) has taken no calls yet
   No Callers
```
Мы также можем приостанавливать и возобновлять участников в очереди из консоли Asterisk, используя команды `queuepause member` и `queue unpause member`. Они используют формат, аналогичный предыдущим командам, которые мы использовали:
```
*CLI> queue pause member PJSIP/SOFTPHONE_B queue support reason Callbacks

paused interface 'PJSIP/SOFTPHONE_B' in queue 'support' for reason 'Callbacks'

*CLI> queue show support
support has 0 calls (max unlimited) in 'rrmemory' strategy
(0s holdtime, 0s talktime), W:0, C:0, A:0, SL:0.0% within 0s
   Members:
      SIP/0000FFFF0001 (dynamic) (paused) (Not in use) has taken no calls yet
   No Callers

*CLI> queue show support

support has 0 calls (max unlimited) in 'rrmemory' strategy (0s holdtime, 0s talktime),
 W:0, C:0, A:0, SL:0.0%, SL2:0.0% within 0s
   Members:
      PJSIP/SOFTPHONE_B (ringinuse disabled) (dynamic) (paused:Callbacks) (Not in use)
has taken no calls yet
   No Callers
```
Добавляя причину (reason) приостановки работы участника очереди, например, время обеда (lunchtime), вы гарантируете, что ваши журналы очереди будут содержать дополнительную информацию, которая может оказаться полезной. Вот как можно приостановить участника:
```
*CLI> queue unpause member PJSIP/SOFTPHONE_B queue support reason FinishedCallBacks

unpaused interface 'PJSIP/SOFTPHONE_B' in queue 'support' for reason 'FinishedCallbacks'
```
В производственной среде CLI (интерфейс командной строки) обычно не является лучшим способом управления состоянием агентов в очереди. Вместо этого существуют приложения диалплана, которые позволяют агентам информировать очередь об их доступности.

### Определение участников очереди в таблице queue_members

Если вы определите участника очереди в таблице базы данных `asterisk.queue_members`, этот участник всегда будет зарегистрирован в очереди. Это обычно не очень хорошо, если ваши участники люди, так как люди, как правило, встают и передвигаются.

В каждом определении очереди вы просто определяете участников следующим образом:
```
MySQL> insert into `asterisk`.`queue_members`
(queue_name,interface,penalty)

VALUES
'hotline','PJSIP/SOME_NON_HUMAN','0');
```
В типичной очереди (в которой есть группа людей, отвечающих за ответы на вызовы), вы обнаружите, что определение участников в таблицу `queue_members` может навредить. Агенты должны иметь возможность входить и выходить из системы (а не автоматически регистрироваться всякий раз, когда очередь перезагружается). Мы не рекомендуем определять участников в таблице `queue_members`, если только нет других целей (таких как банк устройств, отвечающих на вызовы, где вы хотите использовать очередь для балансировки нагрузки вызовов в пул устройств или групповой вызов , где все телефоны звонят одновременно, независимо от того, сидит ли кто-нибудь рядом с телефоном).

### Управление участниками очереди с помощью логики диалплана

В колл-центре, в котором работают живые агенты, чаще всего сами агенты входят в систему и выходят из нее в начале и в конце своей смены (или когда они идут на обед, или в ванную, или иным образом недоступны для очереди).

Для этого мы будем использовать следующие приложения диалплана:

* `AddQueueMember()`
* `RemoveQueueMember()`

При входе в очередь может случиться так, что агенту необходимо перевести себя в состояние, когда он временно недоступен для приема вызовов. Следующие приложения позволят сделать это:

* `PauseQueueMember()`
* `UnpauseQueueMember()`

Приложения`Add`/`Remove` используются для входа и выхода из системы, а `Pause`/`Unpause` используются для коротких периодов отсутствия агента. Разница лишь в том, что `Pause` и `Unpause` устанавливают элемент как недоступный / доступный (`unavailable`/`available`), фактически не удаляя их из очереди. Это в основном полезно для отчетности (если участник приостановлен, администратор очереди может видеть, что он вошел в очередь, но просто недоступен для приема вызовов в этот момент). Если вы не уверены, какой из них использовать, мы рекомендуем агентам использовать `Add`/`Remove`, когда они физически не находятся у своего телефона, и `Pause`/`Unpause`, когда они находятся на своем рабочем месте, но временно недоступны.

Если есть сомнения, обычно лучше, чтобы ваши агенты вышли из системы (log out).

**Использование Пауза и Снять с паузы**

В некоторых средах `Pause` и `Unpause` используются для всех действий в течение дня, которые делают агента недоступным (например, во время обеденного перерыва и при выполнении работы, не связанной с очередью). Однако в большинстве центров обработки вызовов, если агент не находится рядом с телефоном и не готов принять вызов в этот момент, он вообще не должен входить в систему, даже если он будет отсутствовать на рабочем месте в течение нескольких минут. (например, для перерыва в ванной).

Некоторым руководителям нравится использовать настройки `Pause`/` Unpause` как своего рода часы, чтобы они могли отслеживать, когда их сотрудники приходят на работу и уезжают в конце дня, а также сколько времени они проводят за своими столами и на перерывах. Это может быть неразумной практикой, так как цель этих приложений-информировать очередь о доступности агента, а отслеживая активность- вторичной функцией.

Здесь важно отметить, что параметр `joinempty` в таблице `asterisk.queues` был рассмотрен ранее. Если агент приостановлен, он все еще находится в очереди. Предположим, что рабочая смена подходит к концу, а один агент несколько часов назад поставил себя на паузу для работы над проектом. Все остальные агенты вышли из системы и ушли домой. Поступает вызов. Очередь заметит, что агент вошел в очередь, и, следовательно, поставит вызов в очередь, несмотря на то, что в действительности в это время в этой очереди нет людей, способных ответить на вызов. Этот абонент может в конечном итоге задержаться в очереди без персонала на неопределенный срок.

Короче говоря, агенты, которые не сидят за столами и не планируют принимать звонки в течение следующих нескольких минут, должны выйти из системы. `Pause`/`Unpause` следует использовать только для кратковременных моментов недоступности (если вообще есть). Если вы хотите использовать свою телефонную систему в качестве звонильно-долбёжного агрегата, есть много отличных способов сделать это с помощью Asterisk, но приложения `queue member` это не тот способ, который мы посоветуем.

Давайте создадим простую логику набора номеров, которая позволит нашим агентам указывать свою доступность для очереди. Мы собираемся использовать функцию диалплана `CUT()`, чтобы извлечь имя нашего канала из нашего вызова в систему, чтобы очередь знала, какой канал входит в очередь.

Мы создали этот диалплан, чтобы показать простой процесс входа и выхода из очереди, а также изменения приостановленного статуса участника в очереди. Мы делаем это только для одной очереди, которую мы ранее определили в файле _queues.conf_. Переменные канала состояния, установленные приложениями `AddQueueMember()`, `Removeueemember()`, `Pauseueememember()` и `Unpauseuememember()`, могут использоваться для воспроизведения `Playback()` объявлений членам очереди после выполнения ими определенных функций, чтобы сообщить им, успешно ли они совершили вход/выход или пауза/продолжение:
```
exten => *731,1,Page(${PAGELIST},i,120)
exten => *732,1,Verbose(2,Logging In Queue Member)
 same => n,Set(MemberChannel=${CHANNEL(channeltype)}/${CHANNEL(endpoint)})
 same => n,AddQueueMember(support,${MemberChannel})
 same => n,Verbose(1,${AQMSTATUS}) ; ADDED, MEMBERALREADY, NOSUCHQUEUE
 same => n,Playback(agent-loginok)
 same => n,Hangup()

exten => *733,1,Verbose(2,Logging Out Queue Member)
 same => n,Set(MemberChannel=${CHANNEL(channeltype)}/${CHANNEL(endpoint)})
 same => n,RemoveQueueMember(support,${MemberChannel})
 same => n,Verbose(1,${RQMSTATUS}) ; REMOVED, NOTINQUEUE, NOSUCHQUEUE
 same => n,Playback(agent-loggedoff)
 same => n,Hangup()

exten => *734,1,Verbose(2,Pause Queue Member)
 same => n,Set(MemberChannel=${CHANNEL(channeltype)}/${CHANNEL(endpoint)})
 same => n,PauseQueueMember(support,${MemberChannel})
 same => n,Verbose(1,${PQMSTATUS}) ; PAUSED, NOTFOUND
 same => n,Playback(dictate/paused)
 same => n,Hangup()

exten => *735,1,Verbose(2,Unpause Queue Member)

 same => n,Set(MemberChannel=${CHANNEL(channeltype)}/${CHANNEL(endpoint)})
 same => n,UnpauseQueueMember(support,${MemberChannel})
 same => n,Verbose(1,${UPQMSTATUS}) ; UNPAUSED, NOTFOUND
 same => n,Playback(agent-loginok)
 same => n,Hangup()

exten => *98,1,NoOp(Access voicemail retrieval.)
```
### Автоматический вход и выход из нескольких очередей

Довольно часто агент является участником более чем одной очереди. Вместо того, чтобы иметь отдельное расширение для входа в каждую очередь (или требовать от агентов информацию о том, в какие очереди они хотят войти), этот код использует базу данных Asterisk (astdb) для хранения информации о участии в очереди для каждого агента, а затем циклически проходит через каждую очередь, в которую входят агенты, поочередно регистрируя их в каждой очереди.

Для того, чтобы этот код работал, необходимо добавить запись, аналогичную следующей, в AstDB через CLI Asterisk. Например, будет сохранён элемент SOFTPHONE_A как находящийся в очередях `support` и `sales`<sup><a href="#sn3">3</a></sup>
```
CLI> database put queue_agent SOFTPHONE_A/available_queues support^sales
```
Вам нужно будет сделать это один раз для каждого агента, независимо от того, скольких очередей они являются участниками.

Если вы запросите базу данных Asterisk, вы должны получить результат, подобный следующему:
```
pbx*CLI> database show queue_agent
/queue_agent/SOFTPHONE_A/available_queues : support^sales
```
Следующий код диалплана является примером того, как разрешить автоматическое добавление этого участника в очереди `support` и `sales`. Мы определили подпрограмму, которая используется для настройки трех канальных переменных (`Member Channel`,` Member Chan Type`,`AvailableQueues`). Эти переменные канала затем используют расширени Вход (`*736`), Выход (`*737`), Пауза (`*738`) Продолжение (`*739`). Каждое из расширений использует подпрограмму `subSetupAvailableQueues` чтобы установить эти переменные канала и убедиться, что AstDB содержит список одной или нескольких очередей для устройства, с которого вызывается участник очереди.

В конце вашего файла _extensions.conf_, куда вы поместили свои подпрограммы, добавьте следующее:
```
[subSetupAvailableQueues]
; Эта функция используется для различных процедур вход/выход/ пауза/продолжение
; в нашем примере входа в несколько очередей.
;
exten => start,1,Verbose(2,Checking for available queues)
; Get the current channel's peer name
same => n,Set(MemberChannel=${CHANNEL(endpoint)})
; Get the current channel's technology type
same => n,Set(MemberChanType=${CHANNEL(channeltype)})
; Get the list of queues available for this agent
same => n,Set(AvailableQueues=${DB(queue_agent/${MemberChannel}/available_queues)})
; if there are no queues assigned to this agent we'll handle it in the
; no_queues_available extension
same => n,GotoIf($[${ISNULL(${AvailableQueues})}]?no_queues_available,1)
same => n,Return()

exten => no_queues_available,1,Verbose(2,No queues available for agent ${MemberChannel})
; playback a message stating the channel has not yet been assigned
same => n,Playback(silence/1&channel&not-yet-assigned)
same => n,Hangup()
```
Далее, в контекст `[sets]`, добавьте следующие:
```
; Вход в несколько очередей через систему AstDB
exten => *736,1,Verbose(2,Logging into multiple queues per the database values)
; получить доступные очереди для этого канала
same => n,GoSub(subSetupAvailableQueues,start,1())
same => n,Set(QueueCounter=1) ; setup a counter variable
; используя CUT (), получите первую очередь из списка, возвращенную из AstDB.
; Обратите внимание, что мы использовали '^' в качестве разделителя.
same => n,Set(WorkingQueue=${CUT(AvailableQueues,^,${QueueCounter})})
; В то время как переменная канала WorkingQueue содержит значение, цикл
same => n,While($[${EXISTS(${WorkingQueue})}])
; AddQueueMember(queuename[,interface[,penalty[,options[,membername
;  [,stateinterface]]]]])
; Добавить канал в очередь, настроить интерфейс для вызова
;  и интерфейс для мониторинга состояния устройства
; *** Это все должно быть в одной строке
same => n,AddQueueMember(
    ${WorkingQueue},${MemberChanType}/${MemberChannel},,,${MemberChanType}/${MemberChannel})
    same => n,Set(QueueCounter=$[${QueueCounter} + 1])    ; увеличивает наш счетчик
; получить следующую доступную очередь; если она равна нулю, завершить цикл
    same => n,Set(WorkingQueue=${CUT(AvailableQueues,^,${QueueCounter})})
    same => n,EndWhile()
; пусть агент знает, что он вошёл в систему
   same => n,Playback(silence/1&agent-loginok)
   same => n,Hangup()

exten => no_queues_available,1,Verbose(2,No queues available for ${MemberChannel})
   same => n,Playback(silence/1&channel&not-yet-assigned)
   same => n,Hangup()

; Используется для регистрации агентов из всех настроенных очередей в базе данных AstDB
exten => *737,1,Verbose(2,Logging out of multiple queues)
; Поскольку мы повторно использовали некоторый код, мы поместили дубликат кода в подпрограмму
   same => n,GoSub(subSetupAvailableQueues,start,1())
   same => n,Set(QueueCounter=1)
   same => n,Set(WorkingQueue=${CUT(AvailableQueues,^,${QueueCounter})})
   same => n,While($[${EXISTS(${WorkingQueue})}])
   same => n,RemoveQueueMember(${WorkingQueue},${MemberChanType}/${MemberChannel})
   same => n,Set(QueueCounter=$[${QueueCounter} + 1])
   same => n,Set(WorkingQueue=${CUT(AvailableQueues,^,${QueueCounter})})
   same => n,EndWhile()
   same => n,Playback(silence/1&agent-loggedoff)
   same => n,Hangup()

; Используется для приостановки агентов во всех доступных очередях
exten => *738,1,Verbose(2,Pausing member in all queues)
   same => n,GoSub(subSetupAvailableQueues,start,1())
   ; если мы не определяем очередь, то участник приостанавливается во всех очередях
   same => n,PauseQueueMember(,${MemberChanType}/${MemberChannel})
   same => n,GotoIf($[${PQMSTATUS} = PAUSED]?agent_paused,1:agent_not_found,1)

exten => agent_paused,1,Verbose(2,Agent paused successfully)
   same => n,Playback(dictate/paused)
   same => n,Hangup()

; Используется для отмены паузы агентов во всех доступных очередях
exten => *739,1,Verbose(2,UnPausing member in all queues)
   same => n,GoSub(subSetupAvailableQueues,start,1())
 ; если мы не определяем очередь, то элемент не будет приостановлен из всех очередей
   same => n,UnPauseQueueMember(,${MemberChanType}/${MemberChannel})
   same => n,GotoIf($[${UPQMSTATUS} = UNPAUSED]?agent_unpaused,1:agent_not_found,1)

exten => agent_unpaused,1,Verbose(2,Agent paused successfully)
   same => n,Playback(silence/1&available)

; Используется как для приостановки, так и для продолжения функциональности диалплана
exten => agent_not_found,1,Verbose(2,Agent was not found)
   same => n,Playback(silence/1&cannot-complete-as-dialed)
```
Вы можете дополнительно усовершенствовать эти процедуры входа и выхода, чтобы учесть, что переменные канала `AQMSTATUS` и `RQMSTATUS` устанавливаются каждый раз, когда используются `AddQueueMember()` и `Removeueemember()`. Например, можно установить флаг, который позволяет участнику очереди знать, что он не был добавлен в очередь, или даже добавить записи или системы преобразования текста в речь для воспроизведения конкретной очереди, которая создает проблему. Или, если вы отслеживаете это через интерфейс Asterisk Manager, вы можете получить всплывающее окно экрана, или использовать `JabberSend()`, чтобы отправить участнику очереди мгновенное сообщение, или...(Разве Asterisk это не весело?).

## Расширенные очереди

В этом разделе мы рассмотрим некоторые более тонкие элементы управления очередью, такие как параметры управления объявлениями и когда абоненты (callers) должны быть помещены в очередь (или удалены из нее). Мы также рассмотрим пенальти ударение на первую букву "е") и приоритеты, исследуя, как мы можем контролировать агентов в нашей очереди, отдавая предпочтение пулу агентов, а затем увеличивая этот пул динамически на основе времени ожидания в очереди. Наконец, мы рассмотрим использование локальных каналов в качестве участников очереди, что дает нам возможность выполнять трюки диалплана до подключения абонента к агенту.

### Очередь с приоритетом (Queue Weighting)

Иногда вам нужно добавить людей в очередь с более высоким приоритетом, чем у других абонентов. Возможно, абонент уже провел некоторое время в очереди, и агент принял некоторую информацию, но понял, что абонент должен быть переведен в другую очередь. В этом случае, чтобы свести к минимуму общее время ожидания абонента, возможно, было бы желательно перенести вызов в приоритетную очередь, которая имеет более высокий вес (`weight`) (и, следовательно, более высокое предпочтение), где ему быстрее ответят.

Установка более высокого приоритета для очереди выполняется с помощью параметра `weight`. Если у вас есть две очереди с разными весом (например, `support` и `support-priority`), агентам, назначенным в обе очереди, будут переданы вызовы из очереди с более высоким приоритетом, а не вызовы из очереди с более низким приоритетом. Эти агенты не будут принимать никаких вызовов из очереди с более низким приоритетом, пока очередь с более высоким приоритетом не будет очищена. (Обычно есть некоторые агенты, которые назначаются только в очередь с более низким приоритетом, чтобы гарантировать своевременную обработку этих вызовов.) Например, если мы поместим участника очереди Джеймса Шоу в обе очереди `support` и `support-priority`, абоненты в очереди `support-priority` будут иметь предпочтительное положение вместе с Джеймсом, по сравнению с абонентами в очереди `support`.

Давайте посмотрим, как бы мы реализовали это. Во-первых, нам нужно создать новую очередь, аналогичную очереди `support`, за исключением опции `weight`.
```
MySQL> INSERT INTO `asterisk`.`queues`
(name,strategy,joinempty,leavewhenempty,ringinuse,autofill,musiconhold,monitor_format,
monitor_type,weight)

VALUES
('support-priority','rrmemory','unavailable,invalid,unknown','unavailable,invalid,unknown',
'no','yes','default','wav','MixMonitor','10');
```
С нашей новой настроенной очередью мы можем теперь создать два расширения для перевода абонентов. Это можно сделать везде, где вы обычно размещаете логику диалплана для выполнения переводов. Мы будем использовать контекст `LocalSets`, который мы ранее включили в качестве начального контекста для наших устройств:
```
exten => 611,1,Noop()
   same => n,Progress()
   same => n,Queue(support)
   same => n,Hangup()
exten => 612,1,Noop()
   same => n,Progress()
   same => n,Queue(support-priority)
   same => n,Hangup()
exten => *724,1,Noop(Page)
```
Осталось убедиться, что все ваши участники очереди помещены в обе очереди.

### Приоритет Участника Очереди 

Внутри очереди мы можем применить пенальти к участникам, чтобы уменьшить их предпочтение быть вызванными, когда есть люди, ожидающие в определенной очереди. Например, мы можем применять пенальти, когда хотим, чтобы они были участниками очереди, но принимали вызовы только тогда, когда очередь заполнится до тех пор, когда все наши предпочтительные агенты будут недоступны. Выставляя величину пенальти для каждого участника очереди,<sup><a href="#sn4">4</a></sup> мы можем контролировать предпочтения, куда приходят звонки, но при этом гарантировать, что другие участники очереди будут доступны для ответа абонентов, если предпочтительный участник недоступен.

Пенальти также могут быть определены с помощью `AddQueueMember ()`. Мы изменим наш вход в несколько очередей, чтобы обеспечить необходимые пенальти.

Во-первых, давайте обновим нашу AstDB, чтобы включить пенальти для участника:
```
*CLI> database put queue_agent SOFTPHONE_A/penalty 0^2

*CLI> database show queue agent

/queue_agent/SOFTPHONE_A/available_queues : support^sales
/queue_agent/SOFTPHONE_A/penalty : 0^2
```
Далее, несколько изменений в нашем диалплане.
Подпрограмме нужна новая строка (некоторый код был удален для краткости, заменен на; ...):
<pre>
 <code style="font-size:12px">
[subSetupAvailableQueues]
; ...
; Получить список очередей, доступных для этого агента
   same => n,Set(AvailableQueues=${DB(queue_agent/${MemberChannel}/available_queues)})
   <b>same => n,Set(MemberPenalties=${DB(queue_agent/${MemberChannel}/penalty)})</b>
; если нет назначенных очередей ...
 </code>
</pre>
Контекст `[sets]` также требует нескольких новых строк (некоторый код был удален для краткости, заменен на; ...). Только вставляйте / меняйте код, выделенный жирным шрифтом.
<pre>
 <code style="font-size:12px">
exten => *736,1,Verbose(2,Logging into multiple queues per the database values)
; ...
   same => n,Set(WorkingQueue=${CUT(AvailableQueues,^,${QueueCounter})})
   <b>same => n,Set(WorkingPenalty=${CUT(MemberPenalties,^,${QueueCounter})})</b>
; While the WorkingQueue ...
; ...
     same => n,Set(WorkingQueue=${CUT(AvailableQueues,^,${QueueCounter})})
     <b>same => n,Set(WorkingPenalty=${CUT(MemberPenalties,^,${QueueCounter})})</b>
     same => n,EndWhile()
; ...
 </code>
</pre>
Эти примеры, вероятно, не подходят для производственной среды (мы бы использовали специально построенные таблицы MySQL для такого рода вещей, а не AstDB), но это дает вам представление о том, как диалплан может быть использован для применения динамической логики к более сложным сценариям конфигурации.

### Changing Penalties Dynamically (queuerules)

Using the asterisk.queuerules table, it is possible to define rules that change the values of the QUEUE_MIN_PENALTY and QUEUE_MAX_PENALTY channel variables. The QUEUE_MIN_PENALTY and QUEUE_MAX_PENALTY channel variables are used to control which members of a queue are preferred for servicing callers. Let’s say we have a queue called support, and we have five queue members with various penalties ranging from 1 through 5. If, prior to a caller entering the queue, the QUEUE_MIN_PENALTY channel variable is set to a value of 2 and the QUEUE_MAX_PENALTY is set to a value of 4, only queue members whose penalties are set to values ranging from 2 through 4 will be considered available to answer that call:

 same => n,Set(QUEUE_MIN_PENALTY=2) ; set minimum member penalty

 same => n,Set(QUEUE_MAX_PENALTY=4) ; set maximum member penalty

 same => n,Queue(support) ; entering the queue with min and max

 ; member penalties to be used

What’s more, during the caller’s stay in the queue, we can dynamically change the values of QUEUE_MIN_PENALTY and QUEUE_MAX_PENALTY for that caller. This allows either more or a different set of queue members to be used, depending on how long the caller waits in the queue. For instance, in the previous example, we could modify the minimum penalty to 1 and the maximum penalty to 5 if the caller has to wait more than 60 seconds in the queue.

The sample file ~/src/asterisk-15.&lt;TAB>/configs/samples/queuerules.conf.sample contains an excellent reference for how queue rules work.

The rules are defined using the asterisk.queuerules table. Multiple rules can be created in order to facilitate different penalty changes throughout the call. Let’s take a look at how we might choose to define a rule:

MySQL> insert into `asterisk`.`queue_rules`

(rule_name,time,min_penalty,max_penalty)

VALUES

('more_members',60,5,1);

**Note**

New rules will affect only new callers entering the queue, not existing callers already holding.

We’ve named the rule more_members and defined the following values:

60

The number of seconds to wait before changing the penalty values.

5

The new QUEUE_MAX_PENALTY.

1

The new QUEUE_MIN_PENALTY.

We can now tell our queues to make use of it.

MySQL> update `asterisk`.`queues`

set defaultrule='more_members' where `name` in ('sales','support')

The queuerules.conf.sample file shows that these rules are quite flexible. If you want fine-grained control over call prioritization, some additional lab work may be worth your while.

### Announcement Control

Asterisk has the ability to play several announcements to callers waiting in the queue. For example, you might want to announce the caller’s position in the queue, announce the average wait time, or periodically thank your callers for waiting (or whatever your audio files say). It’s important to carefully tune the values that control when these announcements are played to the callers, because announcing their position, thanking them for waiting, and informing them of the average hold time too frequently is going to tend to annoy them, which is not the goal of these things.

**Playing Announcements Between Music on Hold Files**

Instead of handling the intricacies of announcements for each of your queues, you could alternatively (or in conjunction) utilize the announcement functionality defined in musiconhold.conf. Prior to playing a file for music, the announcement file will be played, and then played again between audio files. Let’s say you have a 5-minute loop of audio, but you want to play a “Thank you for waiting” message every 30 seconds. You could split the audio file into 30-second segments, set their filenames as starting with 00-, 01-, 02-, and so on (to keep them playing in order), and then define the announcement. The musiconhold.conf class might look something like this:

[moh_jazz_queue]

mode=files

sort=alpha

announcement=queue-thankyou

directory=moh_jazz_queue

There are several options in the queues table that you can use to fine-tune what and when announcements are played to your callers. The full list of queue options is available in the ~/src/asterisk-15.&lt;TAB>/configs/samples/queues.conf.sample file. [Table 12-3](Asterisk%20%20The%20Definitive%20Guide,%205th%20Edition/12.%20Automatic%20Call%20Distribution%20Queues%20-%20Asterisk%20%20The%20Definitive%20Guide,%205th%20Edition.htm%22%20/l%20%22options_prompt_control_timing_id001) reviews a few of the more useful ones.

Table 12-3. Options related to prompt control timing within a queue

| Option | Available values | Description |
| :--- | :--- | :--- |
| announce-frequency | Value in seconds | Defines how often we should announce the caller’s position and/or estimated hold time in the queue. Set this value to zero to disable. |
| min-announce-frequency | Value in seconds | Indicates the minimum amount of time that must pass before we announce the caller’s position in the queue again. This is used when the caller’s position may change frequently, to prevent the caller hearing multiple updates in a short period of time. |
| periodic-announce-frequency | Value in seconds | Specifies how often to make periodic announcements to the caller. |
| random-periodic-announce | yes, no | If set to yes, will play the defined periodic announcements in a random order. See periodic-announce. |
| relative-periodic-announce | yes, no | If set to yes, the periodic-announce-frequency timer will start when the end of the file being played back is reached, instead of from the beginning. Defaults to no. |
| announce-holdtime | yes, no, once | Defines whether the estimated hold time should be played along with the periodic announcements. Can be set to yes, no, or only once. |
| announce-position | yes, no, limit, more | Defines whether the caller’s position in the queue should be announced to them. If set to no, the position will never be announced. If set to yes, the caller’s position will always be announced. If the value is set to limit, the caller will hear their position in the queue only if it is within the limit defined by announce-position-limit. If the value is set to more, the caller will hear their position only if it is beyond the number defined by announce-position-limit. |
| announce-position-limit | Number of zero or greater | Used if you’ve defined announce-position as either limit or more. |
| announce-round-seconds | Value in seconds | If this value is nonzero, the number of seconds is announced as well, and rounded to the value defined. |

[Table 12-4](Asterisk%20%20The%20Definitive%20Guide,%205th%20Edition/12.%20Automatic%20Call%20Distribution%20Queues%20-%20Asterisk%20%20The%20Definitive%20Guide,%205th%20Edition.htm%22%20/l%20%22options_controlling_playback_prompts) defines the files that will be used when announcements are played to the caller.

Table 12-4. Options for controlling the playback of prompts within a queue

| Option | Available values | Description |
| :--- | :--- | :--- |
| musicclass | Music class as defined by musiconhold.conf | Sets the music class to be used by a particular queue. You can also override this value with the CHANNEL(musicclass) channel variable. |
| queue-thankyou | Filename of prompt to play | If not defined, plays the default value (“Thank you for your patience”). If set to an empty value, prompt will not be played at all. |
| queue-youarenext | Filename of prompt to play | If not defined, plays the default value (“You are now first in line”). If set to an empty value, prompt will not be played at all. |
| queue-thereare | Filename of prompt to play | If not defined, plays the default value (“There are”). If set to an empty value, prompt will not be played at all. |
| queue-callswaiting | Filename of prompt to play | If not defined, plays the default value (“calls waiting”). If set to an empty value, prompt will not be played at all. |
| queue-holdtime | Filename of prompt to play | If not defined, plays the default value (“The current estimated hold time is”). If set to an empty value, prompt will not be played at all. |
| queue-minutes | Filename of prompt to play | If not defined, plays the default value (“minutes”). If set to an empty value, prompt will not be played at all. |
| queue-seconds | Filename of prompt to play | If not defined, plays the default value (“seconds”). If set to an empty value, prompt will not be played at all. |
| queue-reporthold | Filename of prompt to play | If not defined, plays the default value (“hold time”). If set to an empty value, prompt will not be played at all. |
| periodic-announce | A set of periodic announcements to be played, separated by commas | Prompts are played in the order they are defined. Defaults to queue-periodic-announce (“All representatives are currently busy assisting other callers. Please wait for the next available representative”). |

There’s a ton of flexibility possible when designing a caller’s experience while they’re waiting, but please don’t forget that your callers will never be happy to be waiting in the queue. Also, if you’ve found some half-decent hold music, and your callers are enjoying it, an interruption to play yet another message runs the risk of really setting their blood boiling. When they are finally answered, your poor agents will get the brunt of their anger, even though it is actually your fault.[5](https://learning.oreilly.com/library/view/asterisk-the-definitive/9781492031598/ch12.html%22%20/l%20%22idm46178405806600)

So keep your on-hold tweaking simple. Callers know they’re waiting, and they aren’t going to be happy about it. Get them to an agent as quickly as possible, with the bare minimum amount of silliness while they’re holding, and don’t succumb to the temptation of making the queue more important to your callers than it actually is.

### Overflow

Unfortunately, your queue will not always get your callers to an agent in a timely manner. When various conditions cause the queue to reject incoming callers, we have an overflow situation. Overflowing out of the queue is done either with a timeout value or when no queue members are available (as defined by joinempty or leavewhenempty). In this section we’ll discuss how to control when overflow happens.

#### Controlling timeouts

The Queue() application supports two kinds of timeout: one defines the maximum period of time a caller stays in the queue, and the other specifies how long to ring a device when attempting to connect a caller to a queue member. The two are unrelated but can affect each other. In this section we’ll be talking about the maximum period of time a caller stays in the Queue() application before the call overflows to the next step in the dialplan, which could be something like VoiceMail(), or even another queue. Once the call has fallen out of the queue, it can go anywhere that a call could normally go when controlled by the dialplan.

The timeouts are specified in two locations. The timeout that indicates how long to ring queue members for is specified in the queues table. The absolute timeout (how long the caller stays in the queue) is controlled via the Queue() application. To set a maximum amount of time for callers to stay in a queue, simply specify it after the queue name in the Queue() application:

; Queue

exten => 610,1,Noop()

 same => n,Progress()

 same => n,Queue(sales,120)

 same => n,Voicemail(${EXTEN}@queues,u)

 same => n,Hangup()

exten => 611,1,Noop()

 same => n,Progress()

 same => n,Queue(support,120)

 same => n,Voicemail(${EXTEN}@queues,u)

 same => n,Hangup()

exten => 612,1,Noop()

 same => n,Progress()

 same => n,Queue(support-priority,120)

 same => n,Voicemail(${EXTEN}@queues,u)

 same => n,Hangup()

Since we’re sending the calls to voicemail, we’ll need some mailboxes:

MySQL> INSERT INTO `asterisk`.`voicemail`

(context,mailbox,password,fullname,email)

VALUES

('queues','610','192837','Queue sales','name@shifteight.org'),

('queues','611','192837','Queue support','name@shifteight.org'),

('queues','612','192837','Queue support-priority','name@shifteight.org');

Of course, we could define a different destination, but the VoiceMail() application is a common overflow destination for a queue. Obviously, sending callers to voicemail is not ideal (they were hoping to speak to someone live), so make sure someone checks it regularly and calls your customers back.

Now, let’s say we have set our absolute timeout to 10 seconds, our timeout value for ringing queue members to 5 seconds, and our retry timeout value to 4 seconds. In this scenario, we would ring the queue member for 5 seconds, then wait 4 seconds before attempting another queue member. That brings us up to 9 seconds of our absolute timeout of 10 seconds. At this point, should we ring the second queue member for 1 second and then exit the queue, or should we ring this member for the full 5 seconds before exiting?

We control which timeout value has priority with the timeoutpriority option in the queues table. The available values are app (the default) and conf. If we want the application timeout (the absolute timeout) to take priority, which would cause our caller to be kicked out after exactly 10 seconds (even though it was just starting to ring an agent), we should set the timeoutpriority value to app. If we want the configuration file timeout to take priority and finish ringing the queue member, which will cause the caller to stay in the queue a little longer, we should set timeoutpriority to conf. The default value is app (which is the default behavior in previous versions of Asterisk). Probably in most cases you’ll want to use conf (especially if you want your caller experience to be as non-weird as possible).

MySQL> update `asterisk`.`queues` set timeoutpriority='conf'

 where name in ('sales','support','support-priority');

The goal is to get callers to agents, yes?

#### Controlling when to join and leave a queue

Asterisk provides two options that control when callers can join and are forced to leave queues, both based on the statuses of the queue members. The first option, joinempty, is used to control whether callers can enter a queue in the first place. The second option, leavewhenempty, is used to control events that will cause callers already in a queue to be removed from that queue (i.e., if all of the queue members become unavailable). Both options allow for a comma-separated list of values to control this behavior, as listed in [Table 12-5](Asterisk%20%20The%20Definitive%20Guide,%205th%20Edition/12.%20Automatic%20Call%20Distribution%20Queues%20-%20Asterisk%20%20The%20Definitive%20Guide,%205th%20Edition.htm%22%20/l%20%22options_joinempty).

Table 12-5. Options that can be set for joinempty or leavewhenempty

| Value | Description |
| :--- | :--- |
| paused | Members are considered unavailable if they are paused. |
| penalty | Members are considered unavailable if their penalties are less than QUEUE_MAX_PENALTY. |
| inuse | Members are considered unavailable if their device status is InUse. |
| ringing | Members are considered unavailable if their device status is Ringing. |
| unavailable | Applies primarily to agent channels; if the agent is not logged in but is a member of the queue, the channel is considered unavailable. |
| invalid | Members are considered unavailable if their device status is Invalid. This is typically an error condition. |
| unknown | Members are considered unavailable if device status is unknown. |
| wrapup | Members are considered unavailable if they are currently in the wrapup time after the completion of a call. |

For joinempty, prior to placing a caller into the queue, all the members are checked for availability using the factors you list as criteria. If all members are deemed to be unavailable, the caller will not be permitted to enter the queue, and dialplan execution will continue at the next priority.[6](https://learning.oreilly.com/library/view/asterisk-the-definitive/9781492031598/ch12.html%22%20/l%20%22idm46178405761096) For the leavewhenempty option, the members’ statuses are checked periodically against the listed conditions; if it is determined that no members are available to take calls, the caller is removed from the queue, with dialplan execution continuing at the next priority.

An example use of joinempty could be:

joinempty=unavailable,invalid,unknown

With this configuration, prior to a caller entering the queue the statuses of all queue members will be checked, and the caller will not be permitted to enter the queue unless at least one queue member is found to have a status that is not unavailable, invalid, or unknown.

The leavewhenempty example could be something like:

leavewhenempty=unavailable,invalid,unknown

In this case, the queue members’ statuses will be checked periodically, and callers will be removed from the queue if no queue members can be found who do not have a status of unavailable, invalid, or unknown.

Previous versions of Asterisk used the values yes, no, strict, and loose as the available values to be assigned. The mapping of those values is shown in [Table 12-6](Asterisk%20%20The%20Definitive%20Guide,%205th%20Edition/12.%20Automatic%20Call%20Distribution%20Queues%20-%20Asterisk%20%20The%20Definitive%20Guide,%205th%20Edition.htm%22%20/l%20%22mapping_old_new_id001).

Table 12-6. Mapping between old and new values for controlling when callers join and leave queues

| Value | Mapping (joinempty) | Mapping (leavewhenempty) |
| :--- | :--- | :--- |
| yes | (empty) | penalty,paused,invalid |
| no | penalty,paused,invalid | (empty) |
| strict | penalty,paused,invalid,unavailable | penalty,paused,invalid,unavailable |
| loose | penalty,invalid | penalty,invalid |

### Using Local Channels

The use of local channels as queue members is a powerful way of executing dialplan code prior to dialing the actual agent’s device. When Queue() decides to present a call to an agent, using local channels allows us to define custom channel variables, write to a logfile, set some limit on call length (e.g., if it is a paid service), send messages of all sorts all over the place, perform database transactions, and perform many of the other actions we might wish to do at that exact moment. Normally, we have no control over when the Queue() application has decided to present a caller to a specific member, but with local channels, we get one final kick at the can, and can even return Congestion(), which will have the effect of returning the caller to the queue, since the queue will not consider this call to have been successfully delivered to an agent (this can be very handy, since some external condition can be evaluated before the call is just fired off to an endpoint).

When using local channels for queues, they are added just like any other channels, typically dynamically through the AddQueueMember() dialplan application.

We’ll need to define the local channel where all the magic happens, and since local channels are typically used in a manner similar to subroutines, we like to name and locate them in the dialplan with the subroutines, with a context name starting with local (akin to how subroutines start with sub). If you’ve been building out your dialplan along with the book, you’ll notice you already have a local channel [localDialDelay]. Add this code somewhere in that part of the dialplan.

[localMemberConnector]

exten => _[A-Za-z0-9].,1,Verbose(2,Connect ${CALLERID(all)} to Agent at ${EXTEN})

 ; filter out any bad characters, allow alphanumeric chars and hyphen

 same => n,Set(QueueMember=${FILTER(A-Za-z0-9-,${EXTEN})})

 ; assign the first field of QueueMember to Technology; hyphen as separator

 same => n,Set(Technology=${CUT(QueueMember,-,1)})

 ; assign the second field of QueueMember to Device using the hyphen separator

 same => n,Set(Device=${CUT(QueueMember,-,2)})

 ; dial the agent

 same => n,Dial(${Technology}/${Device})

 same => n,Hangup()

This code might not make total sense just yet, but what it’s doing is taking the ${EXTEN} (which is a complex alphanumeric string at this point), and slicing and dicing it to extract the actual channel to be called (i.e., we pass as part of the local channel all the information needed to dial the actual channel).

Let’s look at the AddQueueMember code and see if we can make more sense of this:

exten => *740,1,Noop(Logging in device ${CHANNEL(endpoint)} into the support queue)

 same => n,Set(MemberTech=${CHANNEL(channeltype)})

 same => n,Set(MemberIdent=${CHANNEL(endpoint)})

 same => n,Set(Interface=${MemberTech}/${MemberIdent})

 ;;; THE FOLLOWING SHOULD ALL BE ON ONE LINE

same => n,AddQueueMember(support,Local/${MemberTech}-${MemberIdent}@localMemberConnector

,,,${IF($[${MemberTech} = PJSIP]?${Interface})})

 same => n,Playback(silence/1)

 same => n,Playback(${IF($[${AQMSTATUS} = ADDED]?agent-loginok:agent-incorrect)})

 same => n,Hangup()

Once you’ve input all this and reloaded your dialplan, log into the queue by dialing *740, and let’s see what we’ve got.

*CLI> queue show support

support has 0 calls (max unlimited) in 'rrmemory' strategy (1s holdtime, 0s talktime),

W:0, C:1, A:1, SL:0.0%, SL2:0.0% within 0s

 Members:

 PJSIP/SOFTPHONE_A (Local/PJSIP-SOFTPHONE_A@localMemberConnector)

(ringinuse disabled) (dynamic) (Not in use)

 No Callers

The member is now identified to the queue as a local channel named PJSIP-SOFTPHONE_A in the [localMemberConnector] context. (The PJSIP/SOFTPHONE_A channel will be monitored for actual status of the endpoint.) When Queue() decides to send a call to the member, the call will end up in the [localMemberConnector] context, where the EXTEN (PJSIP-SOFTPHONE_A) will be sliced and diced in order to yield our channel type and endpoint,[7](https://learning.oreilly.com/library/view/asterisk-the-definitive/9781492031598/ch12.html%22%20/l%20%22idm46178405718440) which is what will actually be called.

At this point, the purpose of all this extra complexity is not immediately clear. So far we don’t get anything useful out of all this extra code.

So now that we can add devices to the queue using local channels, let’s look at how this might be useful.

Let’s say we have a customer who just can’t stand our best agent. They’re a good customer, so we don’t want to lose them, but it’s our best agent, so we’re not going to fire them.

To set this up, we’re going to assign a caller ID to SOFTPHONE_B, so we have something to match against.

MySQL> UPDATE `asterisk`.`ps_endpoints` SET callerid='SOFTPHONE_B &lt;103>' 

WHERE id='SOFTPHONE_B';

We’re going to build a little trick into our dialplan that will reject the call to the agent if the caller ID matches our sensitive customer.

[localMemberConnector]

exten => _[A-Za-z0-9].,1,Verbose(2,Connect ${CALLERID(all)} to Agent at ${EXTEN})

 same => n,Wait(0.1) ; Prevent loop from completely hogging CPU

 same => n,Set(QueueMember=${FILTER(A-Za-z0-9-_,${EXTEN})}) ; allow alphanum, - , _

 same => n,Set(Technology=${CUT(QueueMember,-,1)}) ; first field, hyphen is separator

 same => n,Set(Device=${CUT(QueueMember,-,2)}) ; second field, hypen separator

 ; is this our mismatched pair?

 same => n,DumpChan()

 same => n,Noop(${CALLERID(all)} : ${Device})

same=>n,GotoIf($["${CALLERID(num)}"="103"&"${Device}"="SOFTPHONE_A"]?rejectcall:ringagent)

 ; dial the agent

 same => n(ringagent),Dial(${Technology}/${Device})

 same => n,Hangup()

 ; send it back!

 same => n(rejectcall),Congestion()

 same => n,Hangup()

The passing back of Congestion() will cause the caller to be returned to the queue (while this is happening, the caller gets no indication that anything is amiss and keeps hearing music until their call is answered by a channel of some sort).[8](https://learning.oreilly.com/library/view/asterisk-the-definitive/9781492031598/ch12.html%22%20/l%20%22idm46178405708120) Ideally, your queue is programmed to try another agent; however, you need to keep in mind that if app_queue determines that this member is still its first choice to present the call to, the call will simply be reconnected to the same agent (and get congestion again, and thus potentially create a CPU-hogging logic loop). To avoid this, you will need to ensure your queue is using a distribution strategy such as round_robin, random, or any strategy that ensures the same member is not tried over and over. This is also why we toss a tiny little delay into our [localMemberConnector] context, so if a loop like this does happen, there’s at least a small throttle on it.

Let’s just sanity check our code. Set the caller ID number to something other than 103, and the call should go through.

MySQL> UPDATE `asterisk`.`ps_endpoints` SET callerid='SOFTPHONE_B &lt;123>' 

WHERE id='SOFTPHONE_B';

The use of local channels for your member channels will not make queue design and debugging easier, but it does give you far more power over your queues than just using app_queue on its own, so if you have a complex queue requirement, the use of local channels will give you a level of control you would not have otherwise.

## Queue Statistics: The queue_log File

The queue_log file (commonly located in /var/log/asterisk) contains cumulative event information for the queues defined in your system (such as when a queue is reloaded, when queue members are added or removed, pause/unpause events, and so forth) as well as some call details (e.g., their status and which channels the callers were connected to). The queue log is enabled by default, but it can be controlled via the /etc/asterisk/logger.conf file. There are three options related to the queue_log file specifically:

queue_log

Controls whether the queue log is enabled or not. Valid values are yes or no (defaults to yes).

queue_log_to_file

Controls whether the queue log should be written to a file even when a real-time backend is present. Valid values are yes or no (defaults to no).

queue_log_name

Controls the name of the queue log. The default is queue_log.

The queue log is a pipe-separated list of events. The fields in the queue_log file are as follows:

* UNIX Epoch timestamp of the event
* Unique ID of the call
* Name of the queue
* Name of bridged channel
* Type of event
* Zero or more event parameters

The information contained in the event parameters depends on the type of event. A typical queue_log file will look something like the following:

1530389309|NONE|NONE|NONE|QUEUESTART|

1530409313|CLI|support|PJSIP/SOFTPHONE_B|ADDMEMBER|

1530409467|CLI|support|PJSIP/SOFTPHONE_B|REMOVEMEMBER|

1530409666|NONE|support|PJSIP/SOFTPHONE_B|PAUSE|Callbacks

1530411108|NONE|support|PJSIP/SOFTPHONE_B|UNPAUSE|FinishedCallbacks

1530440239|1530440239.10|support|PJSIP/SOFTPHONE_A|ADDMEMBER|

1530440303|1530440303.16|support|PJSIP/SOFTPHONE_A|REMOVEMEMBER|

1530497165|1530497165.54|support|Local/PJSIP-SOFTPHONE_A@MemberConnector|ADDMEMBER|

1530497388|CLI|support|Local/PJSIP-SOFTPHONE_A@MemberConnector|REMOVEMEMBER|

1530497408|1530497408.60|support|Local/PJSIP-SOFTPHONE_A@localMemberConnector|ADDMEMBER|

1530497506|1530497506.71|support|NONE|ENTERQUEUE||SOFTPHONE_B|1

1530497511|1530497506.71|support|PJSIP/SOFTPHONE_A|CONNECT|5|1530497506.72|4

1530497517|1530497506.71|support|PJSIP/SOFTPHONE_A|COMPLETEAGENT|5|6|1

1530509861|1530509861.134|support|NONE|ENTERQUEUE||SOFTPHONE_B|1

1530509864|1530509861.134|support|PJSIP/SOFTPHONE_A|RINGCANCELED|2224

1530509864|1530509861.134|support|NONE|ABANDON|1|1|3

1530510503|1530510503.156|support|NONE|ENTERQUEUE||103|1

1530510503|1530510503.156|support|PJSIP/SOFTPHONE_A|RINGNOANSWER|0

1530510511|1530510503.156|support|NONE|ABANDON|1|1|8

1530510738|1530510738.163|support|NONE|ENTERQUEUE||123|1

1530510742|1530510738.163|support|PJSIP/SOFTPHONE_A|CONNECT|4|1530510738.164|4

1530510752|1530510738.163|support|PJSIP/SOFTPHONE_A|COMPLETECALLER|4|10|1

As you can see from this example, there may not always be a unique ID for the event. External services, such as the Asterisk CLI, can perform actions on the queue, and in these cases you’ll see something like CLI in the Unique ID field.

The available events and the information they provide are described in [Table 12-7](Asterisk%20%20The%20Definitive%20Guide,%205th%20Edition/12.%20Automatic%20Call%20Distribution%20Queues%20-%20Asterisk%20%20The%20Definitive%20Guide,%205th%20Edition.htm%22%20/l%20%22ACD_id289031).

Table 12-7. Events in the Asterisk queue log

| Event | Information provided |
| :--- | :--- |
| ABANDON | Written when a caller in a queue hangs up before his call is answered by an agent. Three parameters are provided for ABANDON: the position of the caller at hangup, the original position of the caller when entering the queue, and the amount of time the caller waited prior to hanging up. |
| ADDMEMBER | Written when a member is added to the queue. The bridged channel name will be populated with the name of the channel added to the queue. |
| AGENTDUMP | Indicates that the agent hung up on the caller while the queue announcement was being played, prior to them being bridged together. |
| AGENTLOGIN | Recorded when an agent logs in. The bridged channel field will contain something like Agent/9994 if logging in with chan_agent, and the first parameter field will contain the channel logging in (e.g., SIP/0000FFFF0001). |
| AGENTLOGOFF | Logged when an agent logs off, along with a parameter indicating how long the agent was logged in for. Note that since you will often use RemoveQueueMember() for agent log off, this parameter may not be written. See the REMOVEMEMBER event instead. |
| COMPLETEAGENT | Recorded when a call is bridged to an agent and the agent hangs up, along with parameters indicating the amount of time the caller was held in the queue, the length of the call with the agent, and the original position at which the caller entered the queue. |
| COMPLETECALLER | Same as COMPLETEAGENT, except the caller hung up and not the agent. |
| CONFIGURELOAD | Indicates that the queue configuration was reloaded (e.g., via module reload app_queue.so). |
| CONNECT | Written when the caller and the agent are bridged together. Three parameters are also written: the amount of time the caller waited in the queue, the unique ID of the queue member’s channel to which the caller was bridged, and the amount of time the queue member’s phone rang prior to being answered. |
| ENTERQUEUE | Written when a caller enters the queue. Two parameters are also written: the URL (if specified) and the caller ID of the caller. |
| EXITEMPTY | Written when the caller is removed from the queue due to a lack of agents available to answer the call (as specified by the leavewhenempty parameter). Three parameters are also written: the position of the caller in the queue, the original position at which the caller entered the queue, and the amount of time the caller was held in the queue. |
| EXITWITHKEY | Written when the caller exits the queue by pressing a single DTMF key on his phone to exit the queue and continue in the dialplan (as enabled by the context parameter in queues.conf). Four parameters are recorded: the key used to exit the queue, the position of the caller in the queue upon exit, the original position the caller entered the queue at, and the amount of time the caller was waiting in the queue. |
| EXITWITHTIMEOUT | Written when the caller is removed from the queue due to timeout, as specified by the timeout parameter to Queue(). Three parameters are also recorded: the position the caller was in when exiting the queue, the original position of the caller when entering the queue, and the amount of time the caller waited in the queue. |
| PAUSE | Written when a queue member is paused. |
| PAUSEALL | Written when all members of a queue are paused. |
| UNPAUSE | Written when a queue member is unpaused. |
| UNPAUSEALL | Written when all members of a queue are unpaused. |
| PENALTY | Written when a member’s penalty is modified. The penalty can be changed through several means, such as the QUEUE_MEMBER_PENALTY() function, the Asterisk Manager Interface, or the Asterisk CLI commands. |
| REMOVEMEMBER | Written when a queue member is removed from the queue. The bridge channel field will contain the name of the member removed from the queue. |
| RINGNOANSWER | Logged when a queue member is rung for a period of time, and the timeout value for ringing the queue member is exceeded. A single parameter will also be written indicating the amount of time the member’s extension rang. |
| TRANSFER | Written when a caller is transferred to another extension. Additional parameters are also written, which include the extension and context the caller was transferred to, the hold time of the caller in the queue, the amount of time the caller was speaking to a member of the queue, and the original position of the caller when he entered the queue.<sup><a href="#sn9">9</a></sup> |
| SYSCOMPAT | Recorded if an agent attempts to answer a call, but the call cannot be set up due to incompatibilities in the media setup. |


## Вывод

Мы начали эту главу с рассмотрения основных очередей вызовов, обсуждения того, что они из себя представляют, как они работают и когда вы, возможно, захотите их использовать. После построения простой очереди мы изучили, как управлять участниками очереди с помощью различных средств (включая использование локальных каналов, которые обеспечивают возможность выполнения некоторой логики набора номеров непосредственно перед подключением к участнику очереди). Конечно, нам нужна возможность отслеживать, что делают наши очереди, поэтому мы быстро просмотрели файл _queue_log_ и различные поля, записанные в результате событий, происходящих в наших очередях.

Благодаря информации, представленной в этой главе, вы обладаете большинством базовых знаний, необходимых для реализации очередей в Asterisk.

---

<ol>
<li id="sn1"> Это распространенное заблуждение, что очередь может позволить вам обрабатывать больше вызовов. Это не совсем верно: ваши абоненты все равно захотят поговорить с живым человеком, и они будут только ждать так долго. Другими словами, если у вас мало сотрудников, ваша очередь может оказаться не более чем препятствием для ваших абонентов. Это то же самое, говорите ли вы по телефону или на кассе Walmart. Никто не любит ждать в очереди. Идеальная очередь невидима для звонящих, так как на их звонки отвечают сразу, без ожидания.</li>

<li id="sn2"> Существует несколько книг, в которых обсуждаются метрики колл-центра и доступные стратегии организации очередей, например, «Руководство по метрикам колл-центра» Джеймса Эббота (Роберт Хьюстон Смит).</li>

<li id="sn3"> Мы собираемся использовать символ ^ в качестве разделителя. Возможно, вы могли бы использовать вместо этого другой символ, только если он не тот, который синтаксический анализатор Asterisk будет рассматривать как обычный разделитель (и, таким образом, будет сбит с толку). Поэтому избегайте запятых, точек с запятой и так далее.</li>

<li id="sn4"> Похоже на добавление балласта к жокею или гоночному автомобилю.</li>

[5](https://learning.oreilly.com/library/view/asterisk-the-definitive/9781492031598/ch12.html%22%20/l%20%22idm46178405806600-marker) Just sayin’.

[6](https://learning.oreilly.com/library/view/asterisk-the-definitive/9781492031598/ch12.html%22%20/l%20%22idm46178405761096-marker) If the priority n+1 (from where the Queue() application was called) is not defined, the call will be hung up. In other words, don’t use this functionality unless your dialplan does something useful at the step immediately following Queue().

[7](https://learning.oreilly.com/library/view/asterisk-the-definitive/9781492031598/ch12.html%22%20/l%20%22idm46178405718440-marker) Perhaps we could have used / instead of - as a delimiter, giving us Local/PJSIP/SOFTPHONE_A@localMemberConnector, but we felt that would be more prone to strange syntax errors, and awkward to filter and parse, so we went with -.

[8](https://learning.oreilly.com/library/view/asterisk-the-definitive/9781492031598/ch12.html%22%20/l%20%22idm46178405708120-marker) Obviously, don’t use any dialplan code in your local channel that will answer, such as Answer(), Playback(), and so forth.

<li id="sn9"> Обратите внимание, что при передаче вызывающего абонента с использованием SIP-передач (а не встроенных передач, запускаемых DTMF и настраиваемых в <i>features.conf</i>), событие TRANSFER может не записываться.</li>
</ol>

[Глава 11. Функции АТС, включая парковку, пейджинг и конференц-связь](glava-11.md) | [Содержание](SUMMARY.md) | [Глава 13. Состояния устройств](glava-13.md)